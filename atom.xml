<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://szgyfe.github.io/atom.xml" rel="self"/>
  
  <link href="https://szgyfe.github.io/"/>
  <updated>2023-01-04T10:58:38.953Z</updated>
  <id>https://szgyfe.github.io/</id>
  
  <author>
    <name>szgy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://szgyfe.github.io/2023/01/04/test/"/>
    <id>https://szgyfe.github.io/2023/01/04/test/</id>
    <published>2023-01-04T10:50:44.000Z</published>
    <updated>2023-01-04T10:58:38.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><ol><li>对 Typescript 有个基本认知</li><li>学习 typescript 基本语法</li><li>见识 typescript 类型体操（通过对类型进行编程，加强团队协作）</li></ol><p>typescript 是针对 <strong>团队协作，第三方开发，架构设计</strong>，</p><p>前几天学习底层知识（js 体系，值和引用，闭包，发布订阅，this，面向对象，事件循环，多线程），把功能实现</p><p>今天开始，顶层设计（ts 顶层设计，SOA，依赖注入，微前端），项目要写的足够大，（adword，facebook）</p><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><pre><code class="javascript">取值1，复制一份，给到 a （引用），1 放在栈，a 放在堆，a 是包装对象，简单数据对象let a = 1; // 取值1，复制一份，给到 a （引用），1 放在栈，a 放在堆，a 是包装对象，简单数据对象let b = &#123; value: 1 &#125;; // 堆中创建对象，取地址值，复制一份，给到 b (引用)，b 复杂数据对象// : 左边是堆中引用，右边堆中值// 函数实参：取值，函数形参：堆中引用// . 号是取引用操作</code></pre><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>原始类型 - js 简单数据类型</p><p>给引用添加说明：引用值，必须是这个类型的</p><pre><code class="typescript">let a: number = 1;let b: string = &quot;123123&quot;;let c: boolean = true;// 字面量类型let d: null = null;let e: undefined = undefined;let f: symbol = Symbol();let g: bigInt = BigInt();// ts 反射，在实际代码中，ts 的类型，是真的绑在对象上的// a.toString() a 上是有类型标注的</code></pre><ol><li><p><strong>类型</strong>是小写，js 基础数据<strong>类</strong>，Number，String，Boolean，null，undefined，Symbol，BigInt，除了 null 和 undefined，都是大写</p></li><li><p>类型有数据放在包装对象上的</p></li><li><p>基本数据类型，除了 null 和 undefined，都是直接<strong>小写作为类型注解</strong></p></li></ol><h2 id="为什么要用-ts"><a href="#为什么要用-ts" class="headerlink" title="为什么要用 ts"></a>为什么要用 ts</h2><ol><li>在 js 开发中：<code>Uncaught TypeError</code></li></ol><pre><code class="javascript">let a = 1;a(); // Uncaught TypeError: a is not a functionlet b = &#123; value: 1 &#125;;b.value.c.d.e.f;// Uncaught TypeError: Cannot read properties of undefined (reading &#39;d&#39;)// 没有被 try catch 处理的类型错误：无法读取 undefined 的属性（读取 b）b.value.c?.d?.e?.f; // 可选链 optional chainb.value.c?.()?.[] // ?.() 可选函数调用 ?.[] 可选的数组访问function optionalChain() &#123;  if (b.value.c) &#123;    let data = b.value.c;    if (data.d) &#123;      let dataD = data.d;      if (dataD.e) &#123;        // ..      &#125; else &#123;        return undefined;      &#125;    &#125; else &#123;      return undefined;    &#125;  &#125;&#125;</code></pre><ol start="2"><li>js 中，存在隐式的类型转换</li></ol><p>大量出现的话，无法调试</p><pre><code class="javascript">[&quot;5&quot; - 3, &quot;5&quot; + 3]; // [2, &#39;53&#39;] + 号引用于字符串拼接，是否拼接是看是否出现了字符串&#39;foo&#39;++&#39;foo&#39; // ++ 是个运算符，无法应用于 x ++ x&#39;foo&#39; + + &#39;foo&#39; // 两个运算符 + +, 先计算  +&#39;foo&#39; 取值（NaN）之后，再进行 &#39;foo&#39; + 结果（&#39;fooNaN&#39;）let x= 3;[&#39;5&#39;+x-x, &#39;5&#39;-x+x] // [50, 5]</code></pre><ol start="3"><li>JS 存在运算符优先级</li></ol><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">mdn 运算符优先级</a></p><pre><code class="typescript">let m = 1;let n = true;let o = m + (n ? 1 : 0); // 避免js 的隐式类型转换 + 优先级 12，三元 优先级 3 括号优先级 最高 19</code></pre><ol start="4"><li>闭包访问，值和引用赋值问题，变量遮蔽</li></ol><p>在 ts 下，不存在回调地狱（真的得用 ts，类型完备的代码）</p><ol start="5"><li>函数传参，函数返回</li></ol><p>可以更加方便地封装和复用代码</p><pre><code class="javascript">function test(a, b) &#123;  return a + b;&#125;test(1, Symbol()); // boom</code></pre><pre><code class="typescript">/** * test2 * ctrl+alt 点两下 d * * @param &#123;number&#125; a 第一个参数，数字 * @param &#123;number&#125; b 第二个参数，是个数字 * @return &#123;*&#125;  &#123;number&#125; 返回 number */function test2(a: number, b: number): number &#123;  return a + b;&#125;test2(1, &quot;&quot;); // type Errorlet result = test2(1, 2);result + Symbol(); // type Error</code></pre><h2 id="ts-优势"><a href="#ts-优势" class="headerlink" title="ts 优势"></a>ts 优势</h2><ol><li><p>ts 静态类型语言，构建工具或编译器，会先将大家写得 ts 代码，编译成 js，再运行，在编译的过程中，就会发现大家的错误（<strong>写代码的时候，就已经知道错误了</strong>）</p></li><li><p>ts 方便封装复用，进行团队协作（团队人数变多，项目变大），增加效率，企业无法抵抗 ts 的诱惑</p></li><li><p>自己和自己的协作，我今天写得代码，20 天以后修改，<strong>代码重构</strong></p></li><li><p>架构师，第三方开发者，可以利用 ts，将实际开发者当做 <strong>提线木偶</strong>（类型体操：将类型当做开发语言，针对编程进行编程 —— 元编程）</p></li><li><p>主流新一代前端框架（Angular，react，vue），主流游戏引擎（cocos creator，laya box），主流后端框架（koa，express，fastify，nestjs），主流嵌入式和应用开发（electron 桌面应用，uniapp，ionic，react native） 全部进入 ts 时代</p></li></ol><h2 id="ts-代价"><a href="#ts-代价" class="headerlink" title="ts 代价"></a>ts 代价</h2><ol><li>得写类型声明代码（代码量增加）</li><li>语法量增加（要求增加，代码会变得更加复杂），对 js 的要求更上了一层楼</li></ol><p>ts 是只有在 协作，重构，第三方开发，架构师工作，海量的代码 —— 对 ts 的完全掌握</p><p>ts 只针对编译到 js 的过程生效，对代码运行没有影响</p><p><strong>先编译，再运行</strong></p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><pre><code class="javascript">let a = [&quot;&quot;, 2, Symbol()];a[0] + a[2];</code></pre><p><code>xxx[]</code>:数组类型</p><p><code>(xxx|yyy)[]</code>:不同类型值的数组,每一项的类型，都有可能是 xxx, yyy</p><pre><code class="typescript">let b = [1, 2, 3, 4];// (number|string|boolean)[] // 每一项类型，都有可能是 number 或者 string 或者 booleanlet a = [1, &quot;&quot;, true];// number[]</code></pre><p><code>xxx|yyy|zzz</code> 联合类型</p><pre><code class="javascript">let a: string | number = 1;a = &quot;&quot;;</code></pre><p>数组两种声明方式：</p><pre><code class="typescript">// 直接类型声明let a: number[] = [1, 2, 3];let b: (number | string)[] = [1, 2, 3, 4, &quot;1&quot;, &quot;2&quot;];// 按**类**声明 class A&#123;&#125;  new A(a)  A(a)// 泛型（类型的函数）A&lt;typeof a&gt;let c: Array&lt;number&gt; = [1, 2, 3];let d: Array&lt;number | string&gt; = [1, 2, 3, 4, &quot;1&quot;];</code></pre><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数声明类型定义</p><pre><code class="typescript">/** * JSDoc 描述 * ctrl + alt + d(两下) * 这个函数，是做一个字符串和一个数字的加法 * * @author &#123;杜老师&#125; * @datetime &#123;2022-1-1&#125; * @param &#123;string&#125; a 参数 a 是一个字符串 * @param &#123;number&#125; b 参数 b 是一个数字 * @return &#123;*&#125;  &#123;number&#125; 返回值是一个 number */function test(a: string, b: number): number &#123;  return parseInt(a) + b;&#125;const test = (a: string, b: number): number =&gt; &#123;  return parseInt(a) + b;&#125;;test(&quot;&quot;, 1); // 调用的时候，老师傅指导你写代码</code></pre><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>把类型当做变量</p><p>ts 类型：元编程（针对编程本身就行编程）</p><pre><code class="typescript">type S = string;let a: S = &quot;&quot;;let b: S = &quot;2&quot;;// 函数类型别名type TestFunc = (a: string, b: number) =&gt; undefined;// void 不确定返回了什么 undefined 必须返回 undefinedconst test: TestFunc = (a, b) =&gt; &#123;  // return b + parseInt(a);  return undefined;&#125;;const result = test(&quot;1&quot;, 1);</code></pre><p>函数可选参数</p><pre><code class="typescript">function testFunc(a?: string, b?: number) &#123;  return parseInt(a || &quot;0&quot;) + (b || 0);&#125;testFunc(&quot;&quot;);</code></pre><p>函数是第一类对象，对象是特殊的函数（散列 hash 函数）</p><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><pre><code class="typescript">// ts 是不是会限制 对象结构？ 写接口// ?: 可选类型   string|number 联合类型type A = &#123; username: string; password: string | undefined &#125;;// 合并interface A2 &#123;  username: string;  password?: string;&#125;interface A2 &#123;  age: number;&#125;let a2: A2 = &#123;  username: &quot;&quot;,  password: &quot;&quot;,  age: 1,&#125;;let a: A = &#123;  username: &quot;&quot;,  password: undefined,&#125;;// a.password = 1;let obj = &#123;&#125;;let obj2 = &#123; ...obj, sss: 1 &#125;;// obj2 继承了 obj  混入式继承// 对象信息提取出来：泛化   把类型实现：继承type X = &#123; a: 1 &#125;;type Y = &#123; b: 1 &#125;;let o: Y &amp; X; // 交叉类型// 类型遮蔽let p: &#123; username: string &#125; &amp; &#123; password: string &#125; = &#123;  username: &quot;&quot;,  password: &quot;&quot;,&#125;;interface Obj1 &#123;  username: string;&#125;// ts 的继承，只做类型匹配，不做类型混入interface Obj2 extends Obj1 &#123;  // username: number;  password: string;&#125;let a3: Obj2 = &#123; username: &quot;&quot;, password: &quot;&quot; &#125;;</code></pre><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><pre><code class="typescript">let a = 1;let b = &#123; value: 1 &#125;;function test(a: number): string &#123;  return a.toString();&#125;const result = test(a);</code></pre><p>一般情况下，只有对象声明处，函数声明处，数组声明处的时候，才需要用到类型声明&#x2F;注解</p><p>其他情况下，靠类型推断，就能确认</p><ol><li>类型注解，能省就剩</li><li>多多将鼠标移到变量上，查看类型</li><li>如果还没有熟悉 ts，该注解，该声明的地方，就该进行练习</li></ol><h2 id="类型字面量"><a href="#类型字面量" class="headerlink" title="类型字面量"></a>类型字面量</h2><pre><code class="typescript">// 类型字面量 栈中直接保存数据function test() &#123;  let a: 1 | 2 = 1;  a = 2;  function test2() &#123;    // console.log(a); // 错误    let a: 2 = 2;    console.log(a);  &#125;&#125;</code></pre><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><pre><code class="typescript">// 枚举类型enum Spit &#123;  backend = &quot;那个前端好恶心&quot;,  frontend = &quot;你这个java后端才恶心&quot;,&#125;let b: Spit = Spit.frontend;// 枚举类型默认声明 只是做区分 0，1，2enum Spit2 &#123;  backend, // =0  frontend, // =1&#125;</code></pre><h2 id="对象的迭代声明"><a href="#对象的迭代声明" class="headerlink" title="对象的迭代声明"></a>对象的迭代声明</h2><pre><code class="typescript">let a = &#123; a: 1, b: 2, c: 3 &#125;;a[&quot;a&quot;];a.a;const result = a[&quot;王沛然&quot;];// any// 对象的迭代类型声明let b: &#123; [key: string]: number &#125; = &#123; 王沛然: 3 &#125;;const result2 = b[&quot;王沛然&quot;];// number</code></pre><h2 id="any-amp-ignore"><a href="#any-amp-ignore" class="headerlink" title="any &amp; ignore"></a>any &amp; ignore</h2><p>回退成 js</p><pre><code class="typescript">//  typescript -&gt; anyScriptlet a: any = 1;function test(a: any) &#123;&#125;// @ts-ignore__dirname + &quot;&quot;;let a = 1;// @ts-ignorea + Symbol();</code></pre><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><pre><code class="typescript">// 感叹号打在值后面  值一定不是空的 undefined/null// 非空断言const div = document.querySelector(&quot;#id&quot;)!;let a: any = &quot;&quot;;let b: any = 1;// 类型断言let c = (a + b) as string;</code></pre><p>当我们和后端通讯时，后端返回的数据在后端定义，前端需要再次声明</p><pre><code class="typescript">const result = axios.get(&quot;http://xxx.com&quot;).then((res) =&gt; &#123;  return res as &#123; username: string; password: string &#125;;&#125;);result.then((res) =&gt; &#123;  // res &#123; username: string; password: string &#125;&#125;);</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><pre><code class="typescript">// 写在尖括号里的，就是泛型function test&lt;T&gt;(a: T) &#123;  return a;&#125;// 拿到的全是类型字面量const result = test(&quot;&quot;); // 已经确定要传 number// 泛型是类型的函数let a: Array&lt;string&gt; = [&quot;&quot;, &quot;&quot;];</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>数组的字面量</p><pre><code class="typescript">// “数组字面量”，规定了数组的长度，数组的每一项的类型// 元组let a: [1, 2, 3, string, 5] = [1, 2, 3, &quot;sdfsdfsdf&quot;, 5];</code></pre><h2 id="as-const"><a href="#as-const" class="headerlink" title="as const"></a>as const</h2><p>as const 让类型自动推断为字面量&#x2F;元组</p><pre><code class="typescript">const a = [1, 2, 3, &quot;sdfsdfsdf&quot;, 5] as const;const b = 1 as const;</code></pre><h2 id="泛型是类型的函数"><a href="#泛型是类型的函数" class="headerlink" title="泛型是类型的函数"></a>泛型是类型的函数</h2><pre><code class="typescript">// 类型元编程函数 泛型type A&lt;T&gt; = &#123; value: T &#125;;type Func&lt;T&gt; = (a: T) =&gt; T;type a = 1;// 类型体操：仅仅使用 ts 类型系统，进行编程，结果在代码提示上查看// 类型元编程let a: A&lt;string&gt; = &#123; value: &quot;&quot; &#125;;let b: A&lt;number&gt; = &#123; value: 1 &#125;;let c: A&lt;1&gt; = &#123; value: 1 &#125;;let d: Func&lt;string&gt; = (a: string) =&gt; a;</code></pre><h2 id="协变-amp-逆变"><a href="#协变-amp-逆变" class="headerlink" title="协变&amp;逆变"></a>协变&amp;逆变</h2><p>人工智能张量（tensor）计算</p><pre><code class="typescript">// 类型协变（跟着变）type A = string;type B = &quot;&quot;;let x1: A = &quot;sdfsdfsdf&quot;;let x2: B = &quot;&quot;;// 子类型可以赋值给超类型x1 = x2;// x2 = x1;// 类型逆变 泛型是类型逆变 函数声明也是类型逆变type C = (a: string) =&gt; void;type D = (a: &quot;&quot;) =&gt; void;let y1: C = (a: string) =&gt; &#123;&#125;;y1(&quot;234234&quot;);let y2: D = (a: &quot;&quot;) =&gt; &#123;&#125;;y2(&quot;&quot;);y1(&quot;123&quot;);y1(&quot;王沛然&quot;);y2(&quot;123&quot;);// y1 = y2; 反过来了，子类型出现的地方，不能赋值给父类型出现的地方y2 = y1;</code></pre><h2 id="泛型的逆变推导（泛型上写-if-else）"><a href="#泛型的逆变推导（泛型上写-if-else）" class="headerlink" title="泛型的逆变推导（泛型上写 if else）"></a>泛型的逆变推导（泛型上写 if else）</h2><p>通过已有泛型类型，倒取出其中的类型</p><pre><code class="typescript">type A = number;// 类型条件判断type B = A extends string ? symbol : boolean;type C = Promise&lt;string&gt;;// 倒取出 C 的泛型type D = C extends Promise&lt;infer P&gt; ? P : never;</code></pre><h2 id="keyof-x2F-key-in"><a href="#keyof-x2F-key-in" class="headerlink" title="keyof&#x2F;key in"></a>keyof&#x2F;key in</h2><p>类型的变量声明<code>type</code>, 类型的函数<code>A&lt;T&gt;</code>, 类型的条件判断<strong>extends 语法，infer 语法</strong>，</p><p>只要有 变量，函数，条件，循环 就能写任何逻辑代码</p><pre><code class="typescript">interface Test &#123;  a: number;  b: number;  c: string;&#125;type TestKeys = keyof Test;type Test2 = &#123; [key in TestKeys]: number &#125;;let a: TestKeys = &quot;c&quot;;</code></pre><h2 id="ts-工具泛型"><a href="#ts-工具泛型" class="headerlink" title="ts 工具泛型"></a>ts 工具泛型</h2><pre><code class="typescript">interface Obj &#123;  a: 1;  b: 2;  c: &quot;&quot;;&#125;// 处理后端数据// 对象类型所有属性，都可选 partial 部分type Obj2 = Partial&lt;Obj&gt;;let obj: Obj = &#123; a: 1, b: 2, c: &quot;&quot; &#125;;let obj2: Obj2 = &#123; a: 1 &#125;;// 正向选择 pick 选出type Obj3 = Pick&lt;Obj, &quot;a&quot;&gt;;type Obj4 = Pick&lt;Obj, &quot;a&quot; | &quot;b&quot;&gt;;// 反向选择 omit 隐藏type Obj5 = Omit&lt;Obj, &quot;a&quot;&gt;;function Test(a: string, b: number) &#123;  return a + b;&#125;// 依赖注入必用// 取出函数的参数类型type Var1 = Parameters&lt;typeof Test&gt;;// 取出函数返回值类型type Var2 = ReturnType&lt;typeof Test&gt;;type Test2 = (a: string) =&gt; number;type Var3 = Parameters&lt;Test2&gt;;type Var4 = ReturnType&lt;Test2&gt;;</code></pre><h2 id="类型体操"><a href="#类型体操" class="headerlink" title="类型体操"></a>类型体操</h2><p>手写工具泛型</p><pre><code class="typescript">type Partial2&lt;T extends &#123; [key: string]: any &#125;&gt; = &#123;  [key in keyof T]?: T[key] | undefined;&#125;;type Obj1 = Partial&lt;&#123; a: 1; b: 2 &#125;&gt;;type Obj2 = Partial2&lt;&#123; a: 1; b: 2 &#125;&gt;;type Pick2&lt;T extends &#123; [key: string]: any &#125;, P extends keyof T&gt; = &#123;  [key in P]: T[P];&#125;;type Obj3 = Pick&lt;&#123; a: 1; b: 2; c: 3 &#125;, &quot;a&quot; | &quot;b&quot;&gt;;type Obj4 = Pick2&lt;&#123; a: 1; b: 2; c: 3 &#125;, &quot;a&quot; | &quot;b&quot;&gt;;type ReturnType2&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (  ...args: any[]) =&gt; infer P  ? P  : never;type Func1 = ReturnType2&lt;() =&gt; string&gt;;</code></pre><pre><code class="typescript">type  Obj = &#123;a:1,b:2,c&#123;value:1&#125;&#125;type DeepPaths&lt;T&gt;type Val = DeepPaths&lt;Obj, &#39;c.value&#39;&gt;</code></pre><h2 id="你了解-ts-么？了解，写过，不-any-（12K-）"><a href="#你了解-ts-么？了解，写过，不-any-（12K-）" class="headerlink" title="你了解 ts 么？了解，写过，不 any （12K+）"></a>你了解 ts 么？了解，写过，不 any （12K+）</h2><ul><li><p>ts 是 js 的<strong>类型超集</strong>(ts 可以直接写 js，anyscript)</p></li><li><p>ts 可以对<strong>左值</strong>加上<strong>类型注解</strong>（:T），对<strong>右值</strong>加上<strong>类型断言</strong>(as T, !)，并且会有<strong>类型推断</strong>机制</p></li><li><p>ts 有<strong>泛型</strong>(<T>)机制，<strong>字面值</strong>(:1|2)机制，我认为<strong>元组</strong>([1,string])类似于数组的<strong>字面值</strong>，对象可以<strong>type</strong>或者<strong>interface</strong>声明，其中 interface 可以写多个进行<strong>合并</strong></p></li><li><p>ts 中，有<strong>协变</strong>和<strong>逆变</strong>机制，所以，需要用<strong>infer</strong>取出泛型</p></li><li><p>ts 还有 <strong>key in</strong> 和 <strong>keyof</strong>，可以做类型的迭代</p></li><li><p>ts 中，可以直接进行类型空间的编程，叫做<strong>类型元编程</strong>(Proxy)，把代码提示框当做代码运行时，这种编程方式，又被称为<strong>类型体操</strong></p></li></ul><p><a href="https://github.com/type-challenges/type-challenges/issues?q=label:7258+label:answer">答案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Typescript&quot;&gt;&lt;a href=&quot;#Typescript&quot; class=&quot;headerlink&quot; title=&quot;Typescript&quot;&gt;&lt;/a&gt;Typescript&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;对 Typescript 有个基本认知&lt;/li&gt;
&lt;li&gt;学习 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://szgyfe.github.io/2023/01/03/hello-world/"/>
    <id>https://szgyfe.github.io/2023/01/03/hello-world/</id>
    <published>2023-01-03T07:46:11.837Z</published>
    <updated>2023-01-03T07:46:11.837Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个简约扁平化的Hexo静态主题博客-Quiet</title>
    <link href="https://szgyfe.github.io/2021/11/03/HTML%E3%80%81CSS%E4%B8%93%E9%A2%98/"/>
    <id>https://szgyfe.github.io/2021/11/03/HTML%E3%80%81CSS%E4%B8%93%E9%A2%98/</id>
    <published>2021-11-03T12:33:36.000Z</published>
    <updated>2023-01-04T13:01:42.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href='#1'>一、对BFC的了解</a></p><p><a href='#2'>二、css哪些属性可以继承</a></p><p><a href='#3'>三、水平垂直居中方式</a></p><p><a href='#4'>四、flex弹性盒子是什么</a></p><p><a href='#5'>五、 flex属性 0 1 auto</a></p><p><a href='#6'>六、px、em、rem、vw、%</a></p><p><a href='#7'>七、画一条 0.5px 的线或者说写一个字体大小小于12px的</a></p><p><a href='#8'>八、<code>DOMContentLoaded </code>事件和 Load 事件的区别？</a></p><p><a href='#9'>九、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别</a></p><p><a href='#10'>十、CSS预处理器</a></p><p><a href='#11'>一、阐述一下 CSS Sprites（雪碧图）</a></p><p><a href='#12'>十二、外边距塌陷</a></p><p><a  href='#13'>十三、文本溢出</a></p><p><a  href='#14'>十四、 移除inline-block间隙</a></p><p><a  href='#15'>十五、伪类和伪元素</a></p><p><a  href='#16'>十六、offsetHight、scrollHeight 、clientHight</a></p><p><a  href='#17'>十七、清除浮动的几种方式及原理？</a></p><p><a  href='#18'>十八、说说position定位</a></p><p><a  href='#19'>十九、说说IE盒模型与标准盒模型</a></p><p><a  href='#20'>二十、CSS优先级（权重的计算）</a></p><p><a  href='#21'>二十一、实现一个两边固定中间自适应的布局</a></p><p><a  href='#22'>二十二、CSS 中 link 和@import 的区别？</a></p><p><a  href='#23'>二十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景</a></p><p><a  href='#24'>二十四、HTMLCollection 和NodeList的区别?</a></p><p><a  href='#25'>二十五、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别?</a></p><h2 id="一、对BFC的了解"><a href="#一、对BFC的了解" class="headerlink" title="一、对BFC的了解"></a><a name='1'>一、对BFC的了解</a></h2><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><ul><li>即块格式化上下文，简单来说就是，<code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用<code>BFC</code>呢，<code>BFC</code>可以看做是一个<code>CSS</code>元素属性</li></ul><h4 id="2、触发（创建条件）"><a href="#2、触发（创建条件）" class="headerlink" title="2、触发（创建条件）"></a>2、触发（创建条件）</h4><ul><li>根元素，也就是HTML标签</li><li>浮动</li><li>overflow的值不为 visible，为 auto、scroll、hidden</li><li>display的值为<code>inline-block</code>、<code>inltable-cell</code>、table-caption、table、<code>inline-table</code>、flex、<code>inline-flex</code>、grid、<code>inline-grid</code></li><li>position的值为absolute或fixed</li></ul><h4 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h4><ul><li><p>防止外边距重叠</p><ul><li>问题：当两个上下的盒子都设置了外边距margin时，就会出现外边距重叠的问题，他们两个之间的margin距离会以大的那个大的margin为准（而不是两个margin值相加）</li><li>解决方法：给其中一个盒子包在一个BFC盒子里面（给这个盒子设置<code>overflow:hidden</code>），这样他们属于两个BFC，会互不影响</li></ul></li><li><p>使用Float脱离文档流，高度塌陷的</p><ul><li><p>问题：内容浮动父盒子高度会消失</p></li><li><p>解决方法：给父盒子触发BFC，这样他们属于两个BFC，会互不影响</p></li></ul></li><li><p>两栏布局覆盖</p><ul><li>问题：两栏布局中，给前一个盒子设置浮动，后一个盒子不设置浮动，那么前一个盒子会因为脱离文档流覆盖在后一个盒子的上方</li><li>解决方法：可以把第二个盒子触发BFC</li></ul></li></ul><h2 id="二、css哪些属性可以继承"><a href="#二、css哪些属性可以继承" class="headerlink" title="二、css哪些属性可以继承"></a><a name='2'>二、css哪些属性可以继承</a></h2><pre><code class="css">（1）字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust（2）文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color（3）表格布局属性caption-side border-collapse empty-cells（4）列表属性list-style-type、list-style-image、list-style-position、list-style（5）光标属性cursor（6）元素可见性visibility</code></pre><pre><code class="css">答：每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</code></pre><h2 id="三、水平垂直居中方式"><a href="#三、水平垂直居中方式" class="headerlink" title="三、水平垂直居中方式"></a><a name='3'>三、水平垂直居中方式</a></h2><h4 id="1、水平垂直居中方式一"><a href="#1、水平垂直居中方式一" class="headerlink" title="1、水平垂直居中方式一"></a>1、水平垂直居中方式一</h4><ul><li><code>position</code>和<code>tansform</code>结合起来</li></ul><pre><code class="css">div &#123;  position: absolute;   width: 500px;  height: 300px;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  background-color: pink; &#125;</code></pre><h4 id="2、水平垂直居中方式二"><a href="#2、水平垂直居中方式二" class="headerlink" title="2、水平垂直居中方式二"></a>2、水平垂直居中方式二</h4><ul><li>弹性盒子<code>flex</code></li></ul><pre><code class="css">/*利用flex布局实际使用时应考虑兼容性*/.container &#123;  display: flex;  align-items: center; /*垂直居中*/  justify-content: center; /*水平居中*/&#125;.containerdiv &#123;  width: 100px;  height: 100px;  background-color: pink;&#125;</code></pre><h4 id="3、水平垂直居中方式三"><a href="#3、水平垂直居中方式三" class="headerlink" title="3、水平垂直居中方式三"></a>3、水平垂直居中方式三</h4><ul><li>定位<code>position</code>结合<code>calc</code></li></ul><pre><code class="css">.wp &#123;    position: relative;&#125;.box &#123;    position: absolute;;    top: calc(50% - 50px);    left: calc(50% - 50px);&#125;</code></pre><h4 id="4、水平垂直居中方式四"><a href="#4、水平垂直居中方式四" class="headerlink" title="4、水平垂直居中方式四"></a>4、水平垂直居中方式四</h4><ul><li><code>position</code>结合<code>margin：auto</code></li></ul><pre><code class="css">.son&#123;   position: absolute;   margin: auto;   top: 0;   left: 0;   right: 0;   bottom: 0; &#125;</code></pre><h2 id="四、flex弹性盒子是什么"><a href="#四、flex弹性盒子是什么" class="headerlink" title="四、flex弹性盒子是什么"></a><a name='4'>四、flex弹性盒子是什么</a></h2><pre><code>flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</code></pre><h2 id="五、-flex属性-0-1-auto-分别表示什么"><a href="#五、-flex属性-0-1-auto-分别表示什么" class="headerlink" title="五、 flex属性 0 1 auto 分别表示什么"></a><a name='5'>五、 flex属性 0 1 auto 分别表示什么</a></h2><ul><li>flex-grow 当还有剩余空间时，为有该属性子元素按比例分配剩余空间。默认：0.    <code>flex：1</code>也就相当于<code>flex-group：1</code></li><li>flex-shrink 当子元素的宽度超出父元素时，包含该属性的子元素按比例减去超出的宽度。默认：1.</li><li>flex-basic 指定元素的宽度，优先级高于width</li></ul><pre><code class="css">flex-grow: 0 项目在主轴上的放大比例，0表示不放大flex-shrink: 1 项目在主轴方向的收缩比例。1 表示超出空间全部收缩（不会超出容器了）flex-basis: auto 项目在主轴上的初始大小。auto是项目本身大小</code></pre><h2 id="六、px、em、rem、vw、"><a href="#六、px、em、rem、vw、" class="headerlink" title="六、px、em、rem、vw、%"></a><a name='6'>六、px、em、rem、vw、%</a></h2><ul><li><p>px：固定单位</p></li><li><p>%：% 是相对于父元素的大小设定的比率</p></li><li><p>em：相对单位，相对于父元素的字体大小，如果父元素为16px，1em就是16px</p></li><li><p>rem：相对单位，相对于根元素（HTML）的字体大小，根元素字体的大小也是动态获取当前视口宽度的十分之一</p></li><li><p>vw&#x2F;vh是一个动态值，相当于百分比值，1vw&#x2F;1vh相当于屏幕宽度&#x2F;高度的1%，</p></li></ul><h2 id="七、画一条-0-5px-的线或者说写一个字体大小小于12px的"><a href="#七、画一条-0-5px-的线或者说写一个字体大小小于12px的" class="headerlink" title="七、画一条 0.5px 的线或者说写一个字体大小小于12px的"></a><a name='7'>七、画一条 0.5px 的线或者说写一个字体大小小于12px的</a></h2><pre><code class="bash">采用transform:scale()的方式</code></pre><h2 id="八、DOMContentLoaded-事件和-Load-事件的区别？"><a href="#八、DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="八、DOMContentLoaded 事件和 Load 事件的区别？"></a><a name='8'>八、<code>DOMContentLoaded </code>事件和 Load 事件的区别？</a></h2><pre><code class="bash"> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和 子框架的加载完成。 Load 事件是当所有资源加载完成后触发的。</code></pre><h2 id="九、localstorage、sessionstorage、cookie的区别-浏览器"><a href="#九、localstorage、sessionstorage、cookie的区别-浏览器" class="headerlink" title="九、localstorage、sessionstorage、cookie的区别(浏览器)"></a><a name='9'>九、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别(浏览器)</a></h2><h4 id="1、存储大小不同"><a href="#1、存储大小不同" class="headerlink" title="1、存储大小不同"></a>1、存储大小不同</h4><ul><li><code>localstorage</code>和<code>sessionstorage</code>的最大存储空间为5M，cookie的最大存储空间为4k</li></ul><h4 id="2、生命周期不同"><a href="#2、生命周期不同" class="headerlink" title="2、生命周期不同"></a>2、生命周期不同</h4><ul><li><code>localstorage</code>存储的数据是永久性的，除非人为删除</li><li><code>cookie</code>存储的数据在有效时间之前一直有效，时间过了就无效了</li><li><code>sessionstorage</code>存储的数据在关闭页面会话（关闭标签页）之后就会被清除</li></ul><h4 id="3、数据共享不同"><a href="#3、数据共享不同" class="headerlink" title="3、数据共享不同"></a>3、数据共享不同</h4><ul><li><code>localstorage</code> 和<code>cookie</code>在所有同源窗口共享</li><li><code>sessionstorage </code>只能在当前会话标签共享</li></ul><h2 id="十、CSS预处理器"><a href="#十、CSS预处理器" class="headerlink" title="十、CSS预处理器"></a><a name='10'>十、CSS预处理器</a></h2><pre><code class="bash">预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</code></pre><h2 id="十一、阐述一下-CSS-Sprites（雪碧图）"><a href="#十一、阐述一下-CSS-Sprites（雪碧图）" class="headerlink" title="十一、阐述一下 CSS Sprites（雪碧图）"></a><a name='11'>十一、阐述一下 CSS Sprites（雪碧图）</a></h2><pre><code class="bash">css sprites：精灵图(雪碧图)：把一堆小图片整合在一张大图上，通过css背景图片相关设置(背景图片、背景图是否重复、背景图定位)，显示图片，减轻服务器对图片的请求数量</code></pre><h2 id="十二、外边距塌陷"><a href="#十二、外边距塌陷" class="headerlink" title="十二、外边距塌陷"></a><a name='12'>十二、外边距塌陷</a></h2><h4 id="1、发生情况"><a href="#1、发生情况" class="headerlink" title="1、发生情况"></a>1、发生情况</h4><ul><li><p>同级下上相邻的div一个设置下面的设置margin-top，上面的盒子设置margin-botton 实际他们直接的距离只会取较大的那个值</p></li><li><p>嵌套的父子结构的div，如果父子都设置margin-top，那么两个盒子会一起移动，实际移动的距离也是较大的那个值</p></li></ul><h4 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h4><ul><li>行内块元素 inline-block 不会发生外边距折叠，包括同层级和嵌套元素。</li><li>浮动 float 元素不会发生外边距折叠，包括同层级和嵌套元素。</li><li>绝对定位元素 absolute 不会发生外边距折叠，包括同层级和嵌套元素。</li><li>创建了 BFC 的元素不会和它的子元素发生外边距折叠。</li><li>父子嵌套的情况也可以给父盒子设置border，或者padding</li></ul><h2 id="十三、文本溢出"><a href="#十三、文本溢出" class="headerlink" title="十三、文本溢出"></a><a name='13'>十三、文本溢出</a></h2><ul><li><strong>单行文本溢出</strong></li></ul><pre><code class="css">overflow: hidden;/* 既然是单行文本,就不能换行 */white-space: nowrap;/* 文本溢出的部分,用省略号来代替 */text-overflow: ellipsis;</code></pre><ul><li><strong>多行文本溢出</strong></li></ul><pre><code class="css">-webkit-line-clamp: 2;（用来限制在一个块元素显示的文本的行数，2 表示最多显示 2 行。为了实现该效果，它需要组合其他的 WebKit 属性）display: -webkit-box;（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）-webkit-box-orient: vertical;（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）overflow: hidden;（文本溢出限定的宽度就隐藏内容）text-overflow: ellipsis;（多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本)</code></pre><h2 id="十四、-移除inline-block间隙"><a href="#十四、-移除inline-block间隙" class="headerlink" title="十四、 移除inline-block间隙"></a><a name='22'>十四、 移除inline-block间隙</a></h2><ul><li><p><strong>问题</strong></p><ul><li>在CSS中，当我们将多个行内块元素并排时，会发现同行显示的inline-block元素之间会出现空隙。</li></ul></li><li><p><strong>出现问题原因</strong></p></li><li><p>当使用行内元素排版时，元素之间的符号都会被浏览器渲染，其中就包括换行符和空格，根据 white-space 的处理方式（默认时normal，合并多余空格）会将HTML中回车符换行符转换成空白符，在字体不为0的情况下，会占据空间，这也是我们所看到的 inline-block 元素之间的间隙。</p></li><li><p><strong>解决方法</strong></p></li><li><p>直接删除元素之间的换行符和空格</p><ul><li>父元素设置 font-size 为0，子元素设置正确的 font-size</li></ul></li></ul><h2 id="十五、伪类和伪元素"><a href="#十五、伪类和伪元素" class="headerlink" title="十五、伪类和伪元素"></a><a name='15'>十五、伪类和伪元素</a></h2><ul><li>伪类和伪元素用于修饰一些不在文档树中的信息</li><li>伪类用于文档树中已存在的元素处于某个状态时，给它添加样式，这个状态根据用户行为而定（如 :hover）</li><li>伪元素用于创建一些不在文档树中的元素并设置样式，可以通过这些元素给DOM元素的某些部分设置样式，但是实际这些伪<br>元素并没有真正存在文档树中，只是用户能看到这些元素而已(如 ::before）</li></ul><h2 id="十六、offsetHight、scrollHeight-、clientHight"><a href="#十六、offsetHight、scrollHeight-、clientHight" class="headerlink" title="十六、offsetHight、scrollHeight 、clientHight"></a><a name='16'>十六、offsetHight、scrollHeight 、clientHight</a></h2><ul><li><p><code>offsetHight：border +padding +content</code></p></li><li><p><code>clientHeight ：border +padding</code></p></li><li><p><code>scrollHeight：padding +实际内容高度</code>（如：当前这个盒子里有个比这个盒子大的盒子，就产生了滚动条，那么实际内容高度就为里面那个盒子的高度+padding）</p></li><li><p><strong>其他相关</strong> </p><ul><li><code>scrollTop</code>、<code>scrollLeft</code> ：<code>元素.scrollTop</code>：元素被卷去的头部，<code>元素.scrollLeft</code>: 元素被卷去的左侧距离</li></ul></li><li><p><code>widow.scrollTo（x，y</code>）:滚动到指定坐标</p></li></ul><pre><code class="javascript">  widow.scroll(&#123; //滚动到指定坐标      top：0//返回顶部      behavior：smooth//平滑滚动      &#125;)//接收一个对象</code></pre><ul><li><code>offsetTop</code>:获取元素到最近带有定位的父元素的距离，如果没有则相对于body（只读属性，不能设置）<ul><li><p>获取页面被卷去的高度</p><ul><li><code>doument.documentElement.scrollTop</code>：返回值是一个数字 ：卷去的数值</li></ul></li><li><p><code>widow.pageYoffset</code>(但是这个属性不能修改，只能获取)</p></li></ul></li></ul><h2 id="十七、清除浮动的几种方式及原理？"><a href="#十七、清除浮动的几种方式及原理？" class="headerlink" title="十七、清除浮动的几种方式及原理？"></a><a name='17'>十七、清除浮动的几种方式及原理？</a></h2><pre><code class="bash">答：清除浮动主要是为了解决父盒子里的子盒子浮动导致父盒子高度塌陷为0的问题方法：1、直接给父盒子添加高度2、添加一个空标签 并设置clear：both3、创建BFC：给父盒子设置overflow：hidden或者auto4、使用after伪元素清楚浮动5、使用before和after双伪元素清楚浮动</code></pre><p>清除浮动的方法：</p><h4 id="1、父级div定义-height"><a href="#1、父级div定义-height" class="headerlink" title="1、父级div定义 height"></a>1、父级div定义 height</h4><ul><li><p>原理：父级div有了固定的height，就解决了无法获取到高度的问题。</p></li><li><p>优点：简单、代码少。</p></li><li><p>缺点：只适合已知高度的布局</p></li></ul><h4 id="2、使用空标签清除浮动clear-both"><a href="#2、使用空标签清除浮动clear-both" class="headerlink" title="2、使用空标签清除浮动clear:both"></a>2、使用空标签清除浮动clear:both</h4><ul><li><p>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度</p></li><li><p>优点：简单、代码少、浏览器支持好</p></li><li><p>缺点：如果页面浮动布局多，就要增加很多空div（添加无意义标签，语义化差，所以不建议使用。）</p></li></ul><pre><code class="css">.clear &#123;        clear: both;&#125;</code></pre><h4 id="3、-创建BFC就可以包含住浮动的子元素"><a href="#3、-创建BFC就可以包含住浮动的子元素" class="headerlink" title="3、 创建BFC就可以包含住浮动的子元素"></a>3、 创建BFC就可以包含住浮动的子元素</h4><ul><li>使用<code>overflow</code>的方法（<code>hidden</code>和<code>auto</code>都可以实现）</li></ul><pre><code class="css">.father &#123;        overflow: hidden;&#125;</code></pre><h4 id="4、伪类元素-after清除浮动（推荐使用）"><a href="#4、伪类元素-after清除浮动（推荐使用）" class="headerlink" title="4、伪类元素::after清除浮动（推荐使用）"></a>4、伪类元素::after清除浮动（推荐使用）</h4><ul><li><p>添加一个不可见但占位置的块级元素，然后清除掉所有的浮动；</p></li><li><p>优点：符合闭合浮动思想，结构语义化正确</p></li><li><p>缺点：ie6-7不支持伪元素：after，使用zoom:1触发hasLayout。</p></li></ul><pre><code class="css">.clearfix::after &#123;       content: &quot;&quot;;        display: block;        height: 0;        visibility: hidden;        clear: both;&#125;/* ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行 */.clearfix &#123;    zoom: 1;&#125;</code></pre><h4 id="5、-双伪类元素-after和-before清除浮动（推荐使用）"><a href="#5、-双伪类元素-after和-before清除浮动（推荐使用）" class="headerlink" title="5、 双伪类元素:after和:before清除浮动（推荐使用）"></a>5、 双伪类元素:after和:before清除浮动（推荐使用）</h4><ul><li>原理与单伪元素清除浮动一样；</li></ul><pre><code class="css"> /* 使用：after和:before双伪元素清除浮动 */ .clearfix::after, .clearfix::before &#123;         content: &quot;&quot;;         display: table; &#125;.clearfix::after &#123;         clear: both; &#125; .clearfix &#123;         *zoom: 1; &#125;</code></pre><h2 id="十八、position定位"><a href="#十八、position定位" class="headerlink" title="十八、position定位"></a><a name='18'>十八、position定位</a></h2><ul><li>static ： 默认值，静态定位</li><li>relative ： 相对定位，即相对于元素的正常位置进行定位</li><li>absolute：绝对定位，相对于第一个非 static 定位的父级元素进行定位</li><li>fixed： 固定定位，相对于浏览器窗口进行定位</li><li>sticky： 粘性定位，它是 relative 和 fixed 的结合体，能够实现类似吸附的效果</li></ul><h2 id="十九、说说IE盒模型与标准盒模型"><a href="#十九、说说IE盒模型与标准盒模型" class="headerlink" title="十九、说说IE盒模型与标准盒模型"></a><a name='19'>十九、说说IE盒模型与标准盒模型</a></h2><p>有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）</p><p>盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）四个部分。</p><ul><li>W3C<strong>标准盒模型</strong></li></ul><pre><code class="css">属性width，height只包含内容content，不包含border和padding也就是说我们设置的宽高对应的是盒子的content内容的宽高盒子实际的宽或高 = 我们设置的宽或高+padding+border</code></pre><ul><li>IE<strong>盒模型</strong></li></ul><pre><code class="css">属性width，height包含content、border和padding，指的是content+padding+border。也就是说我们设置的宽高就是盒子实际的宽高，我们设置的宽高包= content+padding+border= 盒子实际的宽高我们可以用box-sizing属性（css3属性）将默认的值content-box改为border-box;也就是将标准盒模型转化为IE盒模型</code></pre><h2 id="二十、CSS优先级（权重的计算）"><a href="#二十、CSS优先级（权重的计算）" class="headerlink" title="二十、CSS优先级（权重的计算）"></a><a name='20'>二十、CSS优先级（权重的计算）</a></h2><pre><code class="bash">!important 的权重最高内联样式，如: style=&quot;...&quot;，权值为1000。id选择器，如: #content，权值为0100。类，伪类、属性选择器，如.content，权值为0010。标签选择器、伪元素选择器，如div ， 权值为0001。通配符、子选择器、相邻选择器等。如*，&gt;， +，权值为0000.继承的样式没有权重 为最低⚠注意：计算不能进位</code></pre><h2 id="二十一、实现一个两边固定中间自适应的布局"><a href="#二十一、实现一个两边固定中间自适应的布局" class="headerlink" title="二十一、实现一个两边固定中间自适应的布局"></a><a name='21'>二十一、实现一个两边固定中间自适应的布局</a></h2><h4 id="1、利用定位实现两侧固定中间自适应"><a href="#1、利用定位实现两侧固定中间自适应" class="headerlink" title="1、利用定位实现两侧固定中间自适应"></a>1、利用定位实现两侧固定中间自适应</h4><ul><li><p>父盒子设置左右 padding 值</p></li><li><p>padding的值为左右两个盒子的宽度，使得左右两个盒子分别定位在父盒子的padding处</p></li><li><p>中间盒子自适应</p></li></ul><pre><code class="html">html结构：&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;css：&lt;style&gt; .father &#123; height: 400px; background-color: pink; position: relative; padding: 0 200px; &#125; .left,.right &#123; width: 200px; height: 300px; background-color: yellow; position: absolute; top: 0; &#125; .left &#123; left: 0; &#125; .right &#123; right: 0; &#125; .center &#123; background-color: blue; height: 350px; &#125;&lt;/style&gt;</code></pre><h4 id="2、利用-flex-布局实现两侧固定中间自适应"><a href="#2、利用-flex-布局实现两侧固定中间自适应" class="headerlink" title="2、利用 flex 布局实现两侧固定中间自适应"></a>2、利用 flex 布局实现两侧固定中间自适应</h4><ul><li>父盒子设置 display:flex;</li><li>左右盒子设置固定宽高</li><li>中间盒子设置 flex:1 ;</li></ul><h4 id="3、利用-bfc-块级格式化上下文-实现两侧固定中间自适应"><a href="#3、利用-bfc-块级格式化上下文-实现两侧固定中间自适应" class="headerlink" title="3、利用 bfc 块级格式化上下文, 实现两侧固定中间自适应"></a>3、利用 bfc 块级格式化上下文, 实现两侧固定中间自适应</h4><ul><li>左右盒子固定宽高，进行浮动</li><li>中间 overflow: hidden;</li><li>注意这里在html结构中中间的盒子要写在两边两个盒子的后面</li></ul><pre><code class="html">&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 注意:left 和 right 必须放在 center 前面 --&gt;&lt;style&gt; .father &#123; height: 500px; background-color: pink; &#125; .left &#123; float: left; width: 200px; height: 400px; background-color: blue; &#125; .right &#123; float: right; width: 200px; height: 400px; background-color: blue; &#125; .center &#123; height: 450px; background-color: green; overflow: hidden; &#125; &lt;/style&gt;     </code></pre><h2 id="二十二、CSS-中-link-和-import-的区别？"><a href="#二十二、CSS-中-link-和-import-的区别？" class="headerlink" title="二十二、CSS 中 link 和@import 的区别？"></a><a name='22'>二十二、CSS 中 link 和@import 的区别？</a></h2><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS连接属性、引入网站标签等；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import引入的CSS将在页面加载完毕后被加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h2 id="二十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景"><a href="#二十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景" class="headerlink" title="二十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景"></a><a name='23'>二十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景</a></h2><ul><li>opacity&#x3D;0，元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click 事件，那么点击该区域，也能触发点击事件的；</li><li>visibility&#x3D;hidden，元素隐藏起来了，但不会改变页面布局，不会触发该元素已经绑定的事件；</li><li>display&#x3D;none，元素隐藏起来l，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</li></ul><h2 id="二十四、HTMLCollection-和NodeList的区别"><a href="#二十四、HTMLCollection-和NodeList的区别" class="headerlink" title="二十四、HTMLCollection 和NodeList的区别?"></a><a name='24'>二十四、HTMLCollection 和NodeList的区别?</a></h2><ul><li><p>node是最顶层的节点 ，包含了document、element、以及文本和注释节点</p></li><li><p>element是元素节点的集合，而HTMLCollection 继承于element</p></li><li><p>HTMLCollection是元素的集合</p></li><li><p>NodeList 是node的集合</p></li><li><p>上述这两个是伪数组</p></li></ul><p>例子：elem.childNodes获取的是子node节点，包括了文本、注释、元素</p><p>而      elem.children 获取的是所有子元素  也就是元素节点，如div span 这些</p><h2 id="二十五、localstorage、sessionstorage、cookie的区别"><a href="#二十五、localstorage、sessionstorage、cookie的区别" class="headerlink" title="二十五、localstorage、sessionstorage、cookie的区别"></a><a name='25'>二十五、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别</a></h2><h4 id="1、存储大小不同-1"><a href="#1、存储大小不同-1" class="headerlink" title="1、存储大小不同"></a>1、存储大小不同</h4><ul><li><code>localstorage</code>和<code>sessionstorage</code>的最大存储空间为5M，cookie的最大存储空间为4k</li></ul><h4 id="2、生命周期不同-1"><a href="#2、生命周期不同-1" class="headerlink" title="2、生命周期不同"></a>2、生命周期不同</h4><ul><li><code>localstorage</code>存储的数据是永久性的，除非人为删除</li><li><code>cookie</code>存储的数据在有效时间之前一直有效，时间过了就无效了</li><li><code>sessionstorage</code>存储的数据在关闭页面会话（关闭标签页）之后就会被清除</li></ul><h4 id="3、数据共享不同-1"><a href="#3、数据共享不同-1" class="headerlink" title="3、数据共享不同"></a>3、数据共享不同</h4><ul><li><code>localstorage</code> 和<code>cookie</code>在所有同源窗口共享</li><li><code>sessionstorage </code>只能在当前会话标签共享</li></ul>]]></content>
    
    
    <summary type="html">采用简约大方的扁平化Hexo-Quiet主题</summary>
    
    
    
    <category term="项目案例" scheme="https://szgyfe.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"/>
    
    
    <category term="Hexo" scheme="https://szgyfe.github.io/tags/Hexo/"/>
    
    <category term="Quiet" scheme="https://szgyfe.github.io/tags/Quiet/"/>
    
    <category term="主题" scheme="https://szgyfe.github.io/tags/%E4%B8%BB%E9%A2%98/"/>
    
    <category term="静态主题" scheme="https://szgyfe.github.io/tags/%E9%9D%99%E6%80%81%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>
