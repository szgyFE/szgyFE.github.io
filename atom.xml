<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://szgyfe.github.io/atom.xml" rel="self"/>
  
  <link href="https://szgyfe.github.io/"/>
  <updated>2023-01-03T07:46:11.837Z</updated>
  <id>https://szgyfe.github.io/</id>
  
  <author>
    <name>szgy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://szgyfe.github.io/2023/01/03/hello-world/"/>
    <id>https://szgyfe.github.io/2023/01/03/hello-world/</id>
    <published>2023-01-03T07:46:11.837Z</published>
    <updated>2023-01-03T07:46:11.837Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTML、CSS学习笔记面试题</title>
    <link href="https://szgyfe.github.io/2021/11/03/HTML%E3%80%81CSS%E4%B8%93%E9%A2%98/"/>
    <id>https://szgyfe.github.io/2021/11/03/HTML%E3%80%81CSS%E4%B8%93%E9%A2%98/</id>
    <published>2021-11-03T12:33:36.000Z</published>
    <updated>2023-01-05T06:31:22.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href='#1'>一、对BFC的了解</a></p><p><a href='#2'>二、css哪些属性可以继承</a></p><p><a href='#3'>三、水平垂直居中方式</a></p><p><a href='#4'>四、flex弹性盒子是什么</a></p><p><a href='#5'>五、 flex属性 0 1 auto</a></p><p><a href='#6'>六、px、em、rem、vw、%</a></p><p><a href='#7'>七、画一条 0.5px 的线或者说写一个字体大小小于12px的</a></p><p><a href='#8'>八、<code>DOMContentLoaded </code>事件和 Load 事件的区别？</a></p><p><a href='#9'>九、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别</a></p><p><a href='#10'>十、CSS预处理器</a></p><p><a href='#11'>一、阐述一下 CSS Sprites（雪碧图）</a></p><p><a href='#12'>十二、外边距塌陷</a></p><p><a href='#13'>十三、文本溢出</a></p><p><a href='#14'>十四、 移除inline-block间隙</a></p><p><a href='#15'>十五、伪类和伪元素</a></p><p><a href='#16'>十六、offsetHight、scrollHeight 、clientHight</a></p><p><a href='#17'>十七、清除浮动的几种方式及原理？</a></p><p><a href='#18'>十八、说说position定位</a></p><p><a href='#19'>十九、说说IE盒模型与标准盒模型</a></p><p><a href='#20'>二十、CSS优先级（权重的计算）</a></p><p><a href='#21'>二十一、实现一个两边固定中间自适应的布局</a></p><p><a  href='#22'>二十二、CSS 中 link 和@import 的区别？</a></p><p><a  href='#23'>二十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景</a></p><p><a  href='#24'>二十四、HTMLCollection 和NodeList的区别?</a></p><p><a  href='#25'>二十五、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别?</a></p><h2 id="一、对BFC的了解"><a href="#一、对BFC的了解" class="headerlink" title="一、对BFC的了解"></a><a name='1'>一、对BFC的了解</a></h2><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><ul><li>即块格式化上下文，简单来说就是，<code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用<code>BFC</code>呢，<code>BFC</code>可以看做是一个<code>CSS</code>元素属性</li></ul><h4 id="2、触发（创建条件）"><a href="#2、触发（创建条件）" class="headerlink" title="2、触发（创建条件）"></a>2、触发（创建条件）</h4><ul><li>根元素，也就是HTML标签</li><li>浮动</li><li>overflow的值不为 visible，为 auto、scroll、hidden</li><li>display的值为<code>inline-block</code>、<code>inltable-cell</code>、table-caption、table、<code>inline-table</code>、flex、<code>inline-flex</code>、grid、<code>inline-grid</code></li><li>position的值为absolute或fixed</li></ul><h4 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h4><ul><li><strong>防止外边距重叠</strong></li><li>问题：当两个上下的盒子都设置了外边距margin时，就会出现外边距重叠的问题，他们两个之间的margin距离会以大的那个大的margin为准（而不是两个margin值相加）<ul><li>解决方法：给其中一个盒子包在一个BFC盒子里面（给这个盒子设置<code>overflow:hidden</code>），这样他们属于两个BFC，会互不影响</li></ul></li><li><strong>使用Float脱离文档流，高度塌陷的</strong><ul><li>问题：内容浮动父盒子高度会消失</li><li>解决方法：给父盒子触发BFC，这样他们属于两个BFC，会互不影响</li></ul></li><li><strong>两栏布局覆盖</strong><ul><li>问题：两栏布局中，给前一个盒子设置浮动，后一个盒子不设置浮动，那么前一个盒子会因为脱离文档流覆盖在后一个盒子的上方</li><li>解决方法：可以把第二个盒子触发BFC</li></ul></li></ul><h2 id="二、css哪些属性可以继承"><a href="#二、css哪些属性可以继承" class="headerlink" title="二、css哪些属性可以继承"></a><a name='2'>二、css哪些属性可以继承</a></h2><pre><code class="css">（1）字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust（2）文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color（3）表格布局属性caption-side border-collapse empty-cells（4）列表属性list-style-type、list-style-image、list-style-position、list-style（5）光标属性cursor（6）元素可见性visibility</code></pre><pre><code class="css">答：每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</code></pre><h2 id="三、水平垂直居中方式"><a href="#三、水平垂直居中方式" class="headerlink" title="三、水平垂直居中方式"></a><a name='3'>三、水平垂直居中方式</a></h2><h4 id="1、水平垂直居中方式一"><a href="#1、水平垂直居中方式一" class="headerlink" title="1、水平垂直居中方式一"></a>1、水平垂直居中方式一</h4><ul><li><code>position</code>和<code>tansform</code>结合起来</li></ul><pre><code class="css">div &#123;  position: absolute;   width: 500px;  height: 300px;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  background-color: pink; &#125;</code></pre><h4 id="2、水平垂直居中方式二"><a href="#2、水平垂直居中方式二" class="headerlink" title="2、水平垂直居中方式二"></a>2、水平垂直居中方式二</h4><ul><li>弹性盒子<code>flex</code></li></ul><pre><code class="css">/*利用flex布局实际使用时应考虑兼容性*/.container &#123;  display: flex;  align-items: center; /*垂直居中*/  justify-content: center; /*水平居中*/&#125;.containerdiv &#123;  width: 100px;  height: 100px;  background-color: pink;&#125;</code></pre><h4 id="3、水平垂直居中方式三"><a href="#3、水平垂直居中方式三" class="headerlink" title="3、水平垂直居中方式三"></a>3、水平垂直居中方式三</h4><ul><li>定位<code>position</code>结合<code>calc</code></li></ul><pre><code class="css">.wp &#123;    position: relative;&#125;.box &#123;    position: absolute;;    top: calc(50% - 50px);    left: calc(50% - 50px);&#125;</code></pre><h4 id="4、水平垂直居中方式四"><a href="#4、水平垂直居中方式四" class="headerlink" title="4、水平垂直居中方式四"></a>4、水平垂直居中方式四</h4><ul><li><code>position</code>结合<code>margin：auto</code></li></ul><pre><code class="css">.son&#123;   position: absolute;   margin: auto;   top: 0;   left: 0;   right: 0;   bottom: 0; &#125;</code></pre><h2 id="四、flex弹性盒子是什么"><a href="#四、flex弹性盒子是什么" class="headerlink" title="四、flex弹性盒子是什么"></a><a name='4'>四、flex弹性盒子是什么</a></h2><pre><code>flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</code></pre><h2 id="五、-flex属性-0-1-auto-分别表示什么"><a href="#五、-flex属性-0-1-auto-分别表示什么" class="headerlink" title="五、 flex属性 0 1 auto 分别表示什么"></a><a name='5'>五、 flex属性 0 1 auto 分别表示什么</a></h2><ul><li>flex-grow 当还有剩余空间时，为有该属性子元素按比例分配剩余空间。默认：0.    <code>flex：1</code>也就相当于<code>flex-group：1</code></li><li>flex-shrink 当子元素的宽度超出父元素时，包含该属性的子元素按比例减去超出的宽度。默认：1.</li><li>flex-basic 指定元素的宽度，优先级高于width</li></ul><pre><code class="css">flex-grow: 0 项目在主轴上的放大比例，0表示不放大flex-shrink: 1 项目在主轴方向的收缩比例。1 表示超出空间全部收缩（不会超出容器了）flex-basis: auto 项目在主轴上的初始大小。auto是项目本身大小</code></pre><h2 id="六、px、em、rem、vw、"><a href="#六、px、em、rem、vw、" class="headerlink" title="六、px、em、rem、vw、%"></a><a name='6'>六、px、em、rem、vw、%</a></h2><ul><li><p>px：固定单位</p></li><li><p>%：% 是相对于父元素的大小设定的比率</p></li><li><p>em：相对单位，相对于父元素的字体大小，如果父元素为16px，1em就是16px</p></li><li><p>rem：相对单位，相对于根元素（HTML）的字体大小，根元素字体的大小也是动态获取当前视口宽度的十分之一</p></li><li><p>vw&#x2F;vh是一个动态值，相当于百分比值，1vw&#x2F;1vh相当于屏幕宽度&#x2F;高度的1%，</p></li></ul><h2 id="七、画一条-0-5px-的线或者说写一个字体大小小于12px的"><a href="#七、画一条-0-5px-的线或者说写一个字体大小小于12px的" class="headerlink" title="七、画一条 0.5px 的线或者说写一个字体大小小于12px的"></a><a name='7'>七、画一条 0.5px 的线或者说写一个字体大小小于12px的</a></h2><pre><code class="bash">采用transform:scale()的方式</code></pre><h2 id="八、DOMContentLoaded-事件和-Load-事件的区别？"><a href="#八、DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="八、DOMContentLoaded 事件和 Load 事件的区别？"></a><a name='8'>八、<code>DOMContentLoaded </code>事件和 Load 事件的区别？</a></h2><pre><code class="bash"> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和 子框架的加载完成。 Load 事件是当所有资源加载完成后触发的。</code></pre><h2 id="九、localstorage、sessionstorage、cookie的区别-浏览器"><a href="#九、localstorage、sessionstorage、cookie的区别-浏览器" class="headerlink" title="九、localstorage、sessionstorage、cookie的区别(浏览器)"></a><a name='9'>九、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别(浏览器)</a></h2><h4 id="1、存储大小不同"><a href="#1、存储大小不同" class="headerlink" title="1、存储大小不同"></a>1、存储大小不同</h4><ul><li><code>localstorage</code>和<code>sessionstorage</code>的最大存储空间为5M，cookie的最大存储空间为4k</li></ul><h4 id="2、生命周期不同"><a href="#2、生命周期不同" class="headerlink" title="2、生命周期不同"></a>2、生命周期不同</h4><ul><li><code>localstorage</code>存储的数据是永久性的，除非人为删除</li><li><code>cookie</code>存储的数据在有效时间之前一直有效，时间过了就无效了</li><li><code>sessionstorage</code>存储的数据在关闭页面会话（关闭标签页）之后就会被清除</li></ul><h4 id="3、数据共享不同"><a href="#3、数据共享不同" class="headerlink" title="3、数据共享不同"></a>3、数据共享不同</h4><ul><li><code>localstorage</code> 和<code>cookie</code>在所有同源窗口共享</li><li><code>sessionstorage </code>只能在当前会话标签共享</li></ul><h2 id="十、CSS预处理器"><a href="#十、CSS预处理器" class="headerlink" title="十、CSS预处理器"></a><a name='10'>十、CSS预处理器</a></h2><pre><code class="bash">预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</code></pre><h2 id="十一、阐述一下-CSS-Sprites（雪碧图）"><a href="#十一、阐述一下-CSS-Sprites（雪碧图）" class="headerlink" title="十一、阐述一下 CSS Sprites（雪碧图）"></a><a name='11'>十一、阐述一下 CSS Sprites（雪碧图）</a></h2><pre><code class="bash">css sprites：精灵图(雪碧图)：把一堆小图片整合在一张大图上，通过css背景图片相关设置(背景图片、背景图是否重复、背景图定位)，显示图片，减轻服务器对图片的请求数量</code></pre><h2 id="十二、外边距塌陷"><a href="#十二、外边距塌陷" class="headerlink" title="十二、外边距塌陷"></a><a name='12'>十二、外边距塌陷</a></h2><h4 id="1、发生情况"><a href="#1、发生情况" class="headerlink" title="1、发生情况"></a>1、发生情况</h4><ul><li><p>同级下上相邻的div一个设置下面的设置margin-top，上面的盒子设置margin-botton 实际他们直接的距离只会取较大的那个值</p></li><li><p>嵌套的父子结构的div，如果父子都设置margin-top，那么两个盒子会一起移动，实际移动的距离也是较大的那个值</p></li></ul><h4 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h4><ul><li>行内块元素 inline-block 不会发生外边距折叠，包括同层级和嵌套元素。</li><li>浮动 float 元素不会发生外边距折叠，包括同层级和嵌套元素。</li><li>绝对定位元素 absolute 不会发生外边距折叠，包括同层级和嵌套元素。</li><li>创建了 BFC 的元素不会和它的子元素发生外边距折叠。</li><li>父子嵌套的情况也可以给父盒子设置border，或者padding</li></ul><h2 id="十三、文本溢出"><a href="#十三、文本溢出" class="headerlink" title="十三、文本溢出"></a><a name='13'>十三、文本溢出</a></h2><ul><li><strong>单行文本溢出</strong></li></ul><pre><code class="css">overflow: hidden;/* 既然是单行文本,就不能换行 */white-space: nowrap;/* 文本溢出的部分,用省略号来代替 */text-overflow: ellipsis;</code></pre><ul><li><strong>多行文本溢出</strong></li></ul><pre><code class="css">-webkit-line-clamp: 2;（用来限制在一个块元素显示的文本的行数，2 表示最多显示 2 行。为了实现该效果，它需要组合其他的 WebKit 属性）display: -webkit-box;（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）-webkit-box-orient: vertical;（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）overflow: hidden;（文本溢出限定的宽度就隐藏内容）text-overflow: ellipsis;（多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本)</code></pre><h2 id="十四、-移除inline-block间隙"><a href="#十四、-移除inline-block间隙" class="headerlink" title="十四、 移除inline-block间隙"></a><a name='14'>十四、 移除inline-block间隙</a></h2><ul><li><p><strong>问题</strong></p><ul><li>在CSS中，当我们将多个行内块元素并排时，会发现同行显示的inline-block元素之间会出现空隙。</li></ul></li><li><p><strong>出现问题原因</strong></p></li></ul><pre><code class="css">当使用行内元素排版时，元素之间的符号都会被浏览器渲染，其中就包括换行符和空格，根据 white-space 的处理方式（默认时normal，合并多余空格）会将HTML中回车符换行符转换成空白符，在字体不为0的情况下，会占据空间，这也是我们所看到的 inline-block 元素之间的间隙</code></pre><ul><li><strong>解决方法</strong><ul><li>直接删除元素之间的换行符和空格</li><li>父元素设置 font-size 为0，子元素设置正确的 font-size</li></ul></li></ul><h2 id="十五、伪类和伪元素"><a href="#十五、伪类和伪元素" class="headerlink" title="十五、伪类和伪元素"></a><a name='15'>十五、伪类和伪元素</a></h2><ul><li>伪类和伪元素用于修饰一些不在文档树中的信息</li><li>伪类用于文档树中已存在的元素处于某个状态时，给它添加样式，这个状态根据用户行为而定（如 :hover）</li><li>伪元素用于创建一些不在文档树中的元素并设置样式，可以通过这些元素给DOM元素的某些部分设置样式，但是实际这些伪元素并没有真正存在文档树中，只是用户能看到这些元素而已(如 ::before）</li></ul><h2 id="十六、offsetHight、scrollHeight-、clientHight"><a href="#十六、offsetHight、scrollHeight-、clientHight" class="headerlink" title="十六、offsetHight、scrollHeight 、clientHight"></a><a name='16'>十六、offsetHight、scrollHeight 、clientHight</a></h2><ul><li><code>offsetHight：border +padding +content</code></li><li><code>clientHeight ：border +padding</code></li><li><code>scrollHeight：padding +实际内容高度</code>（如：当前这个盒子里有个比这个盒子大的盒子，就产生了滚动条，那么实际内容高度就为里面那个盒子的高度+padding）</li><li><strong>其他相关</strong></li></ul><pre><code class="javascript">1、offsetTop:获取元素到最近带有定位的父元素的距离，如果没有则相对于body（只读属性，不能设置）2、scrollTop、scrollLeft 元素.scrollTop：元素被卷去的头部，元素.scrollLeft: 元素被卷去的左侧距离3、widow.scrollTo(x，y):滚动到指定坐标 widow.scroll(&#123; //滚动到指定坐标      top：0//返回顶部      behavior：smooth//平滑滚动      &#125;)//接收一个对象4、获取页面被卷去的高度:doument.documentElement.scrollTop：返回值是一个数字 ：卷去的数值widow.pageYoffset(但是这个属性不能修改，只能获取)</code></pre><h2 id="十七、清除浮动的几种方式及原理？"><a href="#十七、清除浮动的几种方式及原理？" class="headerlink" title="十七、清除浮动的几种方式及原理？"></a><a name='17'>十七、清除浮动的几种方式及原理？</a></h2><pre><code class="bash">答：清除浮动主要是为了解决父盒子里的子盒子浮动导致父盒子高度塌陷为0的问题方法：1、直接给父盒子添加高度2、添加一个空标签 并设置clear：both3、创建BFC：给父盒子设置overflow：hidden或者auto4、使用after伪元素清楚浮动5、使用before和after双伪元素清楚浮动</code></pre><p>清除浮动的方法：</p><h4 id="1、父级div定义-height"><a href="#1、父级div定义-height" class="headerlink" title="1、父级div定义 height"></a>1、父级div定义 height</h4><ul><li><p>原理：父级div有了固定的height，就解决了无法获取到高度的问题。</p></li><li><p>优点：简单、代码少。</p></li><li><p>缺点：只适合已知高度的布局</p></li></ul><h4 id="2、使用空标签清除浮动clear-both"><a href="#2、使用空标签清除浮动clear-both" class="headerlink" title="2、使用空标签清除浮动clear:both"></a>2、使用空标签清除浮动clear:both</h4><ul><li><p>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度</p></li><li><p>优点：简单、代码少、浏览器支持好</p></li><li><p>缺点：如果页面浮动布局多，就要增加很多空div（添加无意义标签，语义化差，所以不建议使用。）</p></li></ul><pre><code class="css">.clear &#123;        clear: both;&#125;</code></pre><h4 id="3、-创建BFC就可以包含住浮动的子元素"><a href="#3、-创建BFC就可以包含住浮动的子元素" class="headerlink" title="3、 创建BFC就可以包含住浮动的子元素"></a>3、 创建BFC就可以包含住浮动的子元素</h4><ul><li>使用<code>overflow</code>的方法（<code>hidden</code>和<code>auto</code>都可以实现）</li></ul><pre><code class="css">.father &#123;        overflow: hidden;&#125;</code></pre><h4 id="4、伪类元素-after清除浮动（推荐使用）"><a href="#4、伪类元素-after清除浮动（推荐使用）" class="headerlink" title="4、伪类元素::after清除浮动（推荐使用）"></a>4、伪类元素::after清除浮动（推荐使用）</h4><ul><li><p>添加一个不可见但占位置的块级元素，然后清除掉所有的浮动；</p></li><li><p>优点：符合闭合浮动思想，结构语义化正确</p></li><li><p>缺点：ie6-7不支持伪元素：after，使用zoom:1触发hasLayout。</p></li></ul><pre><code class="css">.clearfix::after &#123;       content: &quot;&quot;;        display: block;        height: 0;        visibility: hidden;        clear: both;&#125;/* ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行 */.clearfix &#123;    zoom: 1;&#125;</code></pre><h4 id="5、-双伪类元素-after和-before清除浮动（推荐使用）"><a href="#5、-双伪类元素-after和-before清除浮动（推荐使用）" class="headerlink" title="5、 双伪类元素:after和:before清除浮动（推荐使用）"></a>5、 双伪类元素:after和:before清除浮动（推荐使用）</h4><ul><li>原理与单伪元素清除浮动一样；</li></ul><pre><code class="css"> /* 使用：after和:before双伪元素清除浮动 */ .clearfix::after, .clearfix::before &#123;         content: &quot;&quot;;         display: table; &#125;.clearfix::after &#123;         clear: both; &#125; .clearfix &#123;         *zoom: 1; &#125;</code></pre><h2 id="十八、position定位"><a href="#十八、position定位" class="headerlink" title="十八、position定位"></a><a name='18'>十八、position定位</a></h2><ul><li>static ： 默认值，静态定位</li><li>relative ： 相对定位，即相对于元素的正常位置进行定位</li><li>absolute：绝对定位，相对于第一个非 static 定位的父级元素进行定位</li><li>fixed： 固定定位，相对于浏览器窗口进行定位</li><li>sticky： 粘性定位，它是 relative 和 fixed 的结合体，能够实现类似吸附的效果</li></ul><h2 id="十九、说说IE盒模型与标准盒模型"><a href="#十九、说说IE盒模型与标准盒模型" class="headerlink" title="十九、说说IE盒模型与标准盒模型"></a><a name='19'>十九、说说IE盒模型与标准盒模型</a></h2><p>有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）</p><p>盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）四个部分。</p><ul><li>W3C<strong>标准盒模型</strong></li></ul><pre><code class="css">属性width，height只包含内容content，不包含border和padding也就是说我们设置的宽高对应的是盒子的content内容的宽高盒子实际的宽或高 = 我们设置的宽或高+padding+border</code></pre><ul><li>IE<strong>盒模型</strong></li></ul><pre><code class="css">属性width，height包含content、border和padding，指的是content+padding+border。也就是说我们设置的宽高就是盒子实际的宽高，我们设置的宽高包= content+padding+border= 盒子实际的宽高我们可以用box-sizing属性（css3属性）将默认的值content-box改为border-box;也就是将标准盒模型转化为IE盒模型</code></pre><h2 id="二十、CSS优先级（权重的计算）"><a href="#二十、CSS优先级（权重的计算）" class="headerlink" title="二十、CSS优先级（权重的计算）"></a><a name='20'>二十、CSS优先级（权重的计算）</a></h2><pre><code class="bash">!important 的权重最高内联样式，如: style=&quot;...&quot;，权值为1000。id选择器，如: #content，权值为0100。类，伪类、属性选择器，如.content，权值为0010。标签选择器、伪元素选择器，如div ， 权值为0001。通配符、子选择器、相邻选择器等。如*，&gt;， +，权值为0000.继承的样式没有权重 为最低⚠注意：计算不能进位</code></pre><h2 id="二十一、实现一个两边固定中间自适应的布局"><a href="#二十一、实现一个两边固定中间自适应的布局" class="headerlink" title="二十一、实现一个两边固定中间自适应的布局"></a><a name='21'>二十一、实现一个两边固定中间自适应的布局</a></h2><h4 id="1、利用定位实现两侧固定中间自适应"><a href="#1、利用定位实现两侧固定中间自适应" class="headerlink" title="1、利用定位实现两侧固定中间自适应"></a>1、利用定位实现两侧固定中间自适应</h4><ul><li><p>父盒子设置左右 padding 值</p></li><li><p>padding的值为左右两个盒子的宽度，使得左右两个盒子分别定位在父盒子的padding处</p></li><li><p>中间盒子自适应</p></li></ul><pre><code class="html">html结构：&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;css：&lt;style&gt; .father &#123; height: 400px; background-color: pink; position: relative; padding: 0 200px; &#125; .left,.right &#123; width: 200px; height: 300px; background-color: yellow; position: absolute; top: 0; &#125; .left &#123; left: 0; &#125; .right &#123; right: 0; &#125; .center &#123; background-color: blue; height: 350px; &#125;&lt;/style&gt;</code></pre><h4 id="2、利用-flex-布局实现两侧固定中间自适应"><a href="#2、利用-flex-布局实现两侧固定中间自适应" class="headerlink" title="2、利用 flex 布局实现两侧固定中间自适应"></a>2、利用 flex 布局实现两侧固定中间自适应</h4><ul><li>父盒子设置 display:flex;</li><li>左右盒子设置固定宽高</li><li>中间盒子设置 flex:1 ;</li></ul><h4 id="3、利用-bfc-块级格式化上下文-实现两侧固定中间自适应"><a href="#3、利用-bfc-块级格式化上下文-实现两侧固定中间自适应" class="headerlink" title="3、利用 bfc 块级格式化上下文, 实现两侧固定中间自适应"></a>3、利用 bfc 块级格式化上下文, 实现两侧固定中间自适应</h4><ul><li>左右盒子固定宽高，进行浮动</li><li>中间 overflow: hidden;</li><li>注意这里在html结构中中间的盒子要写在两边两个盒子的后面</li></ul><pre><code class="html">&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 注意:left 和 right 必须放在 center 前面 --&gt;&lt;style&gt; .father &#123; height: 500px; background-color: pink; &#125; .left &#123; float: left; width: 200px; height: 400px; background-color: blue; &#125; .right &#123; float: right; width: 200px; height: 400px; background-color: blue; &#125; .center &#123; height: 450px; background-color: green; overflow: hidden; &#125; &lt;/style&gt;     </code></pre><h2 id="二十二、CSS-中-link-和-import-的区别？"><a href="#二十二、CSS-中-link-和-import-的区别？" class="headerlink" title="二十二、CSS 中 link 和@import 的区别？"></a><a name='22'>二十二、CSS 中 link 和@import 的区别？</a></h2><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS连接属性、引入网站标签等；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import引入的CSS将在页面加载完毕后被加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h2 id="二十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景"><a href="#二十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景" class="headerlink" title="二十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景"></a><a name='23'>二十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景</a></h2><ul><li>opacity&#x3D;0，元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click 事件，那么点击该区域，也能触发点击事件的；</li><li>visibility&#x3D;hidden，元素隐藏起来了，但不会改变页面布局，不会触发该元素已经绑定的事件；</li><li>display&#x3D;none，元素隐藏起来l，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</li></ul><h2 id="二十四、HTMLCollection-和NodeList的区别"><a href="#二十四、HTMLCollection-和NodeList的区别" class="headerlink" title="二十四、HTMLCollection 和NodeList的区别?"></a><a name='24'>二十四、HTMLCollection 和NodeList的区别?</a></h2><ul><li><p>node是最顶层的节点 ，包含了document、element、以及文本和注释节点</p></li><li><p>element是元素节点的集合，而HTMLCollection 继承于element</p></li><li><p>HTMLCollection是元素的集合</p></li><li><p>NodeList 是node的集合</p></li><li><p>上述这两个是伪数组</p></li></ul><pre><code class="bash">例子：elem.childNodes获取的是子node节点，包括了文本、注释、元素而 elem.children 获取的是所有子元素  也就是元素节点，如div span 这些</code></pre><h2 id="二十五、localstorage、sessionstorage、cookie的区别"><a href="#二十五、localstorage、sessionstorage、cookie的区别" class="headerlink" title="二十五、localstorage、sessionstorage、cookie的区别"></a><a name='25'>二十五、<code>localstorage</code>、<code>sessionstorage</code>、<code>cookie</code>的区别</a></h2><h4 id="1、存储大小不同-1"><a href="#1、存储大小不同-1" class="headerlink" title="1、存储大小不同"></a>1、存储大小不同</h4><ul><li><code>localstorage</code>和<code>sessionstorage</code>的最大存储空间为5M，cookie的最大存储空间为4k</li></ul><h4 id="2、生命周期不同-1"><a href="#2、生命周期不同-1" class="headerlink" title="2、生命周期不同"></a>2、生命周期不同</h4><ul><li><code>localstorage</code>存储的数据是永久性的，除非人为删除</li><li><code>cookie</code>存储的数据在有效时间之前一直有效，时间过了就无效了</li><li><code>sessionstorage</code>存储的数据在关闭页面会话（关闭标签页）之后就会被清除</li></ul><h4 id="3、数据共享不同-1"><a href="#3、数据共享不同-1" class="headerlink" title="3、数据共享不同"></a>3、数据共享不同</h4><ul><li><code>localstorage</code> 和<code>cookie</code>在所有同源窗口共享</li><li><code>sessionstorage </code>只能在当前会话标签共享</li></ul>]]></content>
    
    
    <summary type="html">采用简约大方的扁平化Hexo-Quiet主题</summary>
    
    
    
    <category term="前端学习" scheme="https://szgyfe.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端面试" scheme="https://szgyfe.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端学习" scheme="https://szgyfe.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="前端笔记" scheme="https://szgyfe.github.io/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记面试题</title>
    <link href="https://szgyfe.github.io/2021/01/13/JavaScript/"/>
    <id>https://szgyfe.github.io/2021/01/13/JavaScript/</id>
    <published>2021-01-13T12:33:36.000Z</published>
    <updated>2023-01-05T06:31:38.084Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><a href='#1'>一、说说数据类型、检测方式、数据存储？</a></p><p><a href='#2'>二、说说null和undefined？</a></p><p><a href='#3'>三、强制类型转化和隐式类型转化？</a></p><p><a href='#4'>四、列举常用的数组方法？</a></p><p><a href='#5'>五、var let const 区别</a></p><p><a href='#6'>六、for….in 和 for…. of区别？</a></p><p><a href='#7'>七、 如何实现数组的随机排序？</a></p><p><a href='#8'>八、伪数组和如何将伪数组转化为真数组？</a></p><p><a href='#9'>九、 原型、原型链、特点？</a></p><p><a href='#10'>十、 作用域、作用链？</a></p><p><a href='#11'>十一、 什么是闭包呀？它有什么作用？会造成什么问题？在哪些实际场景上有应用呢？</a></p><p><a href='#12'>十二、垃圾回收机制、内存泄漏？</a></p><p><a href='#13'>十三、new 操作符具体干了什么呢？如何实现？</a></p><p><a href='#14'>十四、script标签的defer和aync 属性</a></p><p><a href='#15'>十五、 Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></p><p><a href='#16'>十六、谈谈对this的理解？</a></p><p><a href='#17'>十七、call、apply、bind？</a></p><p><a href='#18'>十八、Array.from？</a></p><p><a href='#19'>十九、new Array和Array of？</a></p><p><a href='#20'>二十、可选链 <code>?.</code></a></p><p><a href='#21'>二十一、promise.allsettled？</a></p><p><a href='#22'>二十二、array &#x3D; [] vs array.length &#x3D; 0？</a></p><p><a href='#23'>二十三、|| 和 &amp;&amp; 操作符的返回值？</a></p><p><a href='#24'>二十四、为什么需要微任务、宏任务？</a></p><p><a href='#25'>二十五、Promise并发控制？</a></p><p><a href='#26'>二十六、构造一个全为0的数组（两种方法）？</a></p><p><a href='#27'>二十七、数组的扁平化以及扁平化数组转化为树状结构数组？</a></p><p><a href='#28'>二十八、Blob、ArrayBuffer？</a></p><p><a href='#29'>二十九、合并两个数组对象？</a></p><p><a href='#30'>三十、数组随机排序 ？</a></p><p><a href='#31'>三十一、如何终止一个forEach ？</a></p><p><a href='#32'>三十二、JavaScript传参的方式？</a></p><p><a href='#33'>三十三、0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 嘛？为什么？</a></p><h2 id="一、说说数据类型、检测方式、数据存储？"><a href="#一、说说数据类型、检测方式、数据存储？" class="headerlink" title="一、说说数据类型、检测方式、数据存储？"></a><a name='1'>一、说说数据类型、检测方式、数据存储？</a></h2><h4 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h4><ul><li>简单数据类型：null、undefined、String、Number、symbol、Bigint、Boolean，</li><li>复杂（引用）数据类型：Object对象（Array，Function 、Date、Math等等）</li></ul><h4 id="2、检测数据类型的方法"><a href="#2、检测数据类型的方法" class="headerlink" title="2、检测数据类型的方法"></a>2、检测数据类型的方法</h4><ul><li><code>typeof</code>:返回一个字符串</li></ul><pre><code class="javascript">1.typeof null 结果为object2.typeof 2/1 结果为NAN 优先级大于运算符</code></pre><ul><li><code>instanceof</code>:返回一个布尔值，只能检测复杂数据类型</li><li><code>Object.prototype.toString.call()</code>:这是最优的方法</li></ul><h4 id="3、数据存储"><a href="#3、数据存储" class="headerlink" title="3、数据存储"></a>3、数据存储</h4><ul><li>js中简单数据类型直接存在栈内存中</li><li>引用数据则是将数据存在堆内，在栈中存引用数据类型的引用地址，地址指向堆内存的引用数据</li></ul><h2 id="二、说说null和undefined？"><a href="#二、说说null和undefined？" class="headerlink" title="二、说说null和undefined？"></a><a name='2'>二、说说null和undefined？</a></h2><ul><li>null和undefined都是js基本数据类型</li><li>当使用严格相等 <code>===</code> 比较二者时，它们不相等，因为它们属于不同的类型。</li><li>当使用非严格相等 <code>==</code> 比较二者时，JavaScript 存在一个特殊的规则，<strong>会判定它们相等。</strong>它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值。</li><li>当使用数学式或其他比较方法 <code>&lt; &gt; &lt;= &gt;=</code> 时：null&#x2F;undefined会被转化为数字：<code>null</code> 被转化为 <code>0</code>，<code>undefined</code> 被转化为 <code>NaN</code>。</li><li>另外，在做boolean 转换时 null 、0、’ ‘ 、undefined、NaN都会被转化为false</li></ul><h2 id="三、列举强制类型转化和隐式类型转化"><a href="#三、列举强制类型转化和隐式类型转化" class="headerlink" title="三、列举强制类型转化和隐式类型转化?"></a><a name='3'>三、列举强制类型转化和隐式类型转化?</a></h2><h4 id="1、强制类型转化"><a href="#1、强制类型转化" class="headerlink" title="1、强制类型转化"></a>1、强制类型转化</h4><ul><li>转化成字符串 <code>toString()</code>， <code>String()</code></li><li>转换成数字 <code>Number()</code>、 <code>parseInt()</code>、 <code>parseFloat()</code></li></ul><pre><code class="javascript">1、Number()的方法的规则为：只要需要转化的字符串有不是数字的就会返回NaNconsole.log(Number(&#39;12abc&#39;))//结果为NaN2、parseInt()：转换为number类型 并且保留整数部分，需要转换的数据只要出现字符就会直接返回该字符之前数字部分console.log(parseInt(&#39;12abc&#39;))//结果为123、parseFloat()：转换为number类型 ,并返回一个浮点数</code></pre><h4 id="2、隐式类型转化"><a href="#2、隐式类型转化" class="headerlink" title="2、隐式类型转化"></a>2、隐式类型转化</h4><ul><li><p>字符串的拼接，<code>任何数据+字符串</code>结果都为字符串</p></li><li><p>字符串转化为数字</p><ul><li><code>+str</code>：在字符串前面加个<code>+</code>就能将字符串转化为数字</li><li>除了加法运算以外的运算都能将字符串转化为数字</li></ul></li><li><p>什么情况下会发生布尔值的隐式强制类型转换？</p></li></ul><pre><code class="javascript">（1） if (..) 语句中的条件判断表达式。（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。（3） while (..) 和 do..while(..) 循环中的条件判断表达式。（4） ? : 中的条件判断表达式。（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</code></pre><h2 id="四、列举常用的数组方法？"><a href="#四、列举常用的数组方法？" class="headerlink" title="四、列举常用的数组方法？"></a><a name='4'>四、列举常用的数组方法？</a></h2><h4 id="1、破坏性方法"><a href="#1、破坏性方法" class="headerlink" title="1、破坏性方法"></a>1、破坏性方法</h4><blockquote><p>注：破坏性方法表示方法会改变原数组</p></blockquote><ul><li><p><code>push</code></p><p>在数组的末尾添加一个元素或者多个元素，并返回数组的新长度</p></li><li><p><code>unshift()</code></p><p>在数组的开头添加一个元素或者多个元素，并返回数组的新长度</p></li></ul><pre><code class="javascript">let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]        arr.push(&#39;d&#39;)        console.log(arr);        console.log(arr.push());//[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,&#39;d&#39;]        arr.unshift(&#39;A&#39;)        console.log(arr);        console.log(arr.unshift());//[&#39;A&#39;,&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,&#39;d&#39;]</code></pre><ul><li><p><code>pop()</code></p><p>删除数组的最后一个元素，返回值的被删除的元素</p></li><li><p><code>shift()</code></p><p>删除数组的第一个元素，返回值的被删除的元素</p></li><li><p><code>splice(开始删除的位置，删除的元素个数)</code></p><p>第二个参数不写表示从第一个参数下标开始删除后面的所有元素，返回值是被删除的元素组成的数组</p><p>splice 也可以添加元素 ： splice （起始位置，0 ，添加的元素，添加的元素…），但是添加元素返回的是空数组,只是改变了原数组</p></li><li><p><code>sort()</code></p></li></ul><pre><code class="javascript">sort( function(a,b)&#123; return a-b&#125;)//这是升序 b-a则是降序</code></pre><ul><li><p><code>reserve()</code></p><p>反转原数组，返回反转后的数组</p></li></ul><h4 id="2、非破坏性方法"><a href="#2、非破坏性方法" class="headerlink" title="2、非破坏性方法"></a>2、非破坏性方法</h4><blockquote><p>注：非破坏性方法表示方法不会改变原数组</p></blockquote><ul><li><p><code>slice （截取的起始位置，截取的结束位置）</code>：前闭后开</p><p>截取数组片段，返回一个新截取的数组 不改变原数组，第一个参数不写那么则会一直截取到最后，两个参数都省略可以对数组进行浅拷贝，返回一个新数组</p></li><li><p><code>concat()</code></p><p>连接数组，返回一个新数组 </p></li><li><p><code>indexOf</code>（元素，开始查询此元素的位置）</p><p>获取数组中元素第一次出现的索引，并返回它的索引，没有返回-1</p></li><li><p><code>lastIndexOf </code></p><p>和③ 相同 但是是从后往前找</p></li><li><p><code>join（分隔符）</code></p><p>将数组的元素连接成一个字符串，默认元素之间用逗号隔开，在小括号里面可以指定元素之间的符号 如join（@）：这表示元素之间用@符号隔开，返回一个字符串</p></li><li><p><code>map（function（item，index）&#123;&#125;）</code></p><p>map映射，返回一个新的数组，新数组由每个元素调用回调函数的返回值组成，也就是由回调函数的返回值组成，（有几个元素就有几个返回值）</p></li></ul><pre><code class="javascript">const arr = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;]    const res = arr.map(function(item,index)&#123;      return 1    &#125;)    console.log(res);//res[1,1,1]</code></pre><ul><li><p><code>filter（回调函数作为参数，一般要写返回值，返回true或者false，函数里面传入的是 element，index，array ）</code></p><p>将数组中满足条件的保存到一个新数组中返回，根据回调函数的返回值决定是否将这个元素放入新数组</p></li></ul><pre><code class="javascript">const arr = [10,20,30]        const  res = arr.filter(function(item,index)&#123;            return item &gt; 10        &#125;)        console.log(res)</code></pre><ul><li><p><code>reduce（回调函数（pre,cur）&#123;return pre + cur&#125;，第二个参数：初始值）</code></p><p>逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果相加（上一步的计算结果是当前元素之前所有元素的总和）——直到没有更多的元素被相加。</p></li></ul><pre><code class="javascript">// 语法：arr.reduce(function()&#123;&#125;, initValue)        // 作用：对数组里面的每个元素都执行一个自定义的reducer函数，将其结果汇总为单个返回值。        //   参数 ：         //       callbackFn : 回调函数   必须 √        //       initValue  : 初始值 （可选） √        // callbackFn的参数：   ==&gt; 要写return        //        previousValue :    上一次调用calbackFn 时的返回值  √        //        currentValue  :    当前元素  √        //        currentIndex  :    当前元素的索引  （可选）        //        array         :     源数组 （可选）          //  返回值 ： 使用 “reducer” 回调函数遍历整个数组后的结果。 </code></pre><pre><code class="javascript">const arr = [&#123;            name: &#39;张三&#39;,            salary: 10000        &#125;, &#123;            name: &#39;李四&#39;,            salary: 10000        &#125;, &#123;            name: &#39;王五&#39;,            salary: 20000        &#125;]        const res = arr.reduce(function (prv, cur) &#123;            return prv + cur.salary * 0.3//每一次将当前的元素与上一步的计算结果相加        &#125;, 0)//0时初始值，这里如果不写的话时数组里面的第一个对象        console.log(res)</code></pre><ul><li><p><code>find（function（ele，index，当前数组））</code></p><p>搜索查找,返回数组中满足函数return条件的第一个元素，没有返回undefined</p></li></ul><pre><code class="javascript">const arrTemp = [&#123;name:&#39;小米&#39;, price:1999&#125;,&#123;name:&#39;华为&#39;, price:5999&#125;]        const res = arrTemp.find(function(item,index)&#123;            return item.name = &quot;小米&quot;        &#125;)        console.log(res)//&#123;name:&#39;小米&#39;, price:1999&#125;</code></pre><ul><li><p><code>findIndex（function（ele，index， array）&#123;return xxx&#125;)</code></p><p>返回满足return条件的数组元素的下标，没有返回 -1</p></li><li><p><code>arr.every(cbfn)</code></p><p><code>cbfn</code>是回调函数，检测数组内元素是否都满足return指定条件，如果都满足，返回true，否则 返回false</p></li><li><p><code>arr.some(cbfn)</code></p><p>检测数组内元素至少有一个元素满足return指定条件，如果满足，返回true，否则 返回false</p></li></ul><p><strong>⚠注</strong>：<code>map</code> 、<code>filter</code> 、<code>forEach</code>、<code>find</code>、<code>findIndex</code>、<code>every</code>、<code>some</code>等传入回调函数的参数都是三个分别为：element（当前元素）、index（当前 元素索引）、array（被遍历的数组）且这些都能迭代数组</p><hr><p><strong>总结</strong>：</p><h4 id="1、添加-x2F-删除元素"><a href="#1、添加-x2F-删除元素" class="headerlink" title="1、添加&#x2F;删除元素"></a>1、添加&#x2F;删除元素</h4><ul><li><code>push(...items)</code> —— 向尾端添加元素，</li><li><code>pop()</code> —— 从尾端提取一个元素，</li><li><code>shift()</code> —— 从首端提取一个元素，</li><li><code>unshift(...items)</code> —— 向首端添加元素，</li><li><code>splice(pos, deleteCount, ...items)</code> —— 从 <code>pos</code> 开始删除 <code>deleteCount</code> 个元素，并插入 <code>items</code>到原数组中，（删除和添加同时进行）</li><li><code>slice(start, end)</code> —— 创建一个新数组，将从索引 <code>start</code> 到索引 <code>end</code>（但不包括 <code>end</code>）的元素复制进去。</li><li><code>concat(...items)</code> —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 <code>items</code>。如果 <code>items</code> 中的任意一项是一个数组，那么就取其元素。</li></ul><h4 id="2、搜索元素"><a href="#2、搜索元素" class="headerlink" title="2、搜索元素"></a>2、搜索元素</h4><ul><li><code>indexOf/lastIndexOf(item, pos)</code> —— 从索引 <code>pos</code> 开始搜索 <code>item</code>，搜索到则返回该项的索引，否则返回 <code>-1</code>。</li><li><code>includes(value)</code> —— 如果数组有 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>find/filter(func)</code> —— 通过 <code>func</code> 过滤元素，返回使 <code>func</code> 返回 <code>true</code> 的第一个值&#x2F;所有值。</li><li><code>findIndex</code> 和 <code>find</code> 类似，但返回索引而不是值。</li></ul><h4 id="3、遍历元素"><a href="#3、遍历元素" class="headerlink" title="3、遍历元素"></a>3、遍历元素</h4><ul><li><code>forEach(func)</code> —— 对每个元素都调用 <code>func</code>，不返回任何内容。</li></ul><h4 id="4、转换数组"><a href="#4、转换数组" class="headerlink" title="4、转换数组"></a>4、转换数组</h4><ul><li><code>map(func)</code> —— 根据对每个元素调用 <code>func</code> 的结果创建一个新数组。</li><li><code>sort(func)</code> —— 对数组进行原位排序，然后返回它。</li><li><code>reverse()</code> —— 原位反转数组，然后返回它。</li><li><code>split/join</code> —— 将字符串转换为数组并返回。</li><li><code>reduce/reduceRight(func, 初始值)</code> —— 通过对每个元素调用 <code>func</code> 计算数组上的单个值，并在调用之间传递中间结果。</li></ul><h4 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h4><ul><li><p><code>Array.from()</code>: 将伪数组转化为真数组</p></li><li><p><code>Array.isArray(value)</code> 检查 <code>value</code> 是否是一个数组，如果是则返回 <code>true</code>，否则返回 <code>false</code>。</p></li><li><p>请注意，<code>sort</code>，<code>reverse</code> 和 <code>splice</code> 方法修改的是数组本身。</p></li><li><p><code>arr.flat(depth)</code>从多维数组指定深度创建一个新的扁平数组。返回一个新数组</p></li></ul><h4 id="6、不常用方法"><a href="#6、不常用方法" class="headerlink" title="6、不常用方法"></a>6、不常用方法</h4><ul><li><p><code>[arr.some(fn)]/[arr.every(fn)</code>检查数组。</p><p>与 <code>map</code> 类似，对数组的每个元素调用函数 <code>fn</code>。如果任何&#x2F;所有结果为 <code>true</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p><p>这两个方法的行为类似于 <code>||</code> 和 <code>&amp;&amp;</code> 运算符：如果 <code>fn</code> 返回一个真值，<code>arr.some()</code> 立即返回 <code>true</code> 并停止迭代其余数组项；如果 <code>fn</code> 返回一个假值，<code>arr.every()</code> 立即返回 <code>false</code> 并停止对其余数组项的迭代。</p><p>我们可以使用 <code>every</code> 来比较数组：</p></li></ul><pre><code class="javascript">function arraysEqual(arr1, arr2) &#123;  return arr1.length === arr2.length &amp;&amp; arr1.every((value, index) =&gt; value === arr2[index]);&#125;alert( arraysEqual([1, 2], [1, 2])); // true</code></pre><ul><li><code>arr.fill(value, start, end)</code> —— 从索引 <code>start</code> 到 <code>end</code>，用重复的 <code>value</code> 填充数组。</li><li><code>arr.copyWithin(target, start, end)</code>—— 将从位置 <code>start</code> 到 <code>end</code> 的所有元素复制到 <strong>自身</strong> 的 <code>target</code> 位置（覆盖现有元素）。</li><li><code>Array.of(element0[, element1[, …[, elementN\]]])</code> 基于可变数量的参数创建一个新的 <code>Array</code> 实例，而不需要考虑参数的数量或类型。</li></ul><h2 id="五、var-let-const-区别"><a href="#五、var-let-const-区别" class="headerlink" title="五、var let const 区别"></a><a name='5'>五、var let const 区别</a></h2><ul><li><p><strong>块级作用域</strong>：let、const 有块级作用域，var不存在块级作用域</p><ul><li>解决了ES5的两个问题：内层变量可能覆盖外层变量以及用来计数的变量泄露为全局变量</li><li>另外局部变量在使用完之后就会被销毁</li></ul></li><li><p><strong>变量提升</strong>:var声明的变量回提升到当前作用域的最上方，let和const没有</p></li><li><p><strong>给全局添加属性</strong>：var在全局作用域声明的变量回挂载到window上，let const 不会</p></li><li><p><strong>重复声明</strong>：var变量可以重复声明，let和const不能</p></li><li><p><strong>暂时性死区</strong>：let 和const 声明的变量会存在暂时性死区，在变量被定义之前不能使用该变量</p></li><li><p><strong>初始值</strong>：const声明的变量必须设置初始值，let和var可以不设置</p></li><li><p><strong>指针指向</strong>：let声明的变量可以改变指针指向，也就是可以重新赋值，const不能</p><ul><li>注意：如果const声明的变量指向的是一个引用类型，只要引用地址没改变，指针指向的数据是可以改变的</li></ul></li></ul><h2 id="六、for…-in-和-for…-of区别"><a href="#六、for…-in-和-for…-of区别" class="headerlink" title="六、for….in 和 for…. of区别"></a><a name='6'>六、for….in 和 for…. of区别</a></h2><ul><li>for in 用于可枚举的数据，像是对象，数组，字符串，得到的是key</li><li>for of 用于可迭代的数据，像 数组、字符串、Map、Set 得到的是value</li><li>可枚举可以用<code>Object.getOwnpropertyDescriptors(要检测的对象)</code>，可迭代可以查看<code>Symbol.interator</code>属性里面的<code>next()</code>方法，有就是可迭代 </li><li>连环问：for await…of :用于遍历多个Promise</li></ul><pre><code class="javascript">Promise.all([p1,p2,p3]).then(res=&gt;console.log(res))//可以得到多个promise的执行resolve()的结果for await (let res of [p1,p2,p3])&#123;    console.log(res)//得到的也是多个promise的resolve()的结果&#125;</code></pre><h2 id="七、-如何实现数组的随机排序？"><a href="#七、-如何实现数组的随机排序？" class="headerlink" title="七、 如何实现数组的随机排序？"></a><a name='7'>七、 如何实现数组的随机排序？</a></h2><pre><code class="js">//(1)var arr = [1,2,3,4,5,6,7,8,9,10]; arr.sort(function()&#123; return Math.random() - 0.5; &#125;) console.log(arr);// （2）随机从原数组抽取一个元素，加入到新数组function randomSort(arr) &#123;  var result = [];  while (arr.length &gt; 0) &#123;    var randomIndex = Math.floor(Math.random() * arr.length);    result.push(arr[randomIndex]);    arr.splice(randomIndex, 1);  &#125;  return result;&#125;// （3）随机交换数组内的元素（洗牌算法类似）function randomSort(arr) &#123;  var index,    randomIndex,    temp,    len = arr.length;  for (index = 0; index &lt; len; index++) &#123;    randomIndex = Math.floor(Math.random() * (len - index)) + index;    temp = arr[index];    arr[index] = arr[randomIndex];    arr[randomIndex] = temp;  &#125;  return arr;&#125;// es6function randomSort(array) &#123;  let length = array.length;  if (!Array.isArray(array) || length &lt;= 1) return;  for (let index = 0; index &lt; length - 1; index++) &#123;    let randomIndex = Math.floor(Math.random() * (length - index)) + index;    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];  &#125;  return array;&#125;</code></pre><h2 id="八、伪数组和如何将伪数组转化为真数组"><a href="#八、伪数组和如何将伪数组转化为真数组" class="headerlink" title="八、伪数组和如何将伪数组转化为真数组"></a><a name='8'>八、伪数组和如何将伪数组转化为真数组</a></h2><h4 id="1、伪数组"><a href="#1、伪数组" class="headerlink" title="1、伪数组"></a>1、伪数组</h4><ul><li>具有 length 属性</li><li>按索引方式存储数据</li><li>不能使用数组的 push.pop 等方法但是可以用forEach等方法对其进行遍历</li></ul><h4 id="2、转化为真数组的方法"><a href="#2、转化为真数组的方法" class="headerlink" title="2、转化为真数组的方法"></a>2、转化为真数组的方法</h4><ul><li>用for of 迭代伪数组并将其每一个元素push进一个空数组</li><li>Array.from(arguments)</li><li>展开运算符：newArr &#x3D; […arguments]</li><li>Array.prototype.slice.call(arguments):在原型上调用slice的call方法</li><li>cancat（）：空数组和伪数组连接</li></ul><h4 id="3、检测数组的方法"><a href="#3、检测数组的方法" class="headerlink" title="3、检测数组的方法"></a>3、检测数组的方法</h4><ul><li>arr instansof   Array，返回true或false</li><li>Objeect.prototype.toString.call(arr)，返回的是Arrary</li><li>Array.isArray（arr）：返回true或false</li></ul><h2 id="九、-原型、原型链、特点？"><a href="#九、-原型、原型链、特点？" class="headerlink" title="九、 原型、原型链、特点？"></a><a name='9'>九、 原型、原型链、特点？</a></h2><ul><li><strong>原型</strong>：</li></ul><pre><code class="bash">答：1.原型是一个对象，2.js中所有的函数都有prototype属性，指向它的原型对象，原型对象上有一个constructor指回函数本身3.当我们使用构造函数创建一个实例对象时，对象的内部有一个指针指向构造函数的prototype属性对应的值 ，在ES5中这个指针被称为对象的原型（函数也有这个），一般来说，我们不应该获取这个值，浏览器可以用__proto__属性来获取这个值，但是这是不规范的，我们应该用ES5的Object.getPrototypeOf()的方法来获取对象的原型参考：1、原型就是一个对象2、所有的函数都有一个prototype属性，指向它的原型对象3、所有对象都有一个__proto__属性 指向构造函数得到prototype ，也即是指向原型4、原型上默认有个constructor属性，指回构造函数5、作用 : 可以将属性和方法写在原型里面节约内存6、所有通过构造函数创建的对象都可以共享原型上的方法和属性</code></pre><ul><li><strong>原型链</strong></li></ul><pre><code class="bash">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype </code></pre><ul><li><strong>特点</strong>：</li></ul><pre><code class="bash">JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</code></pre><h2 id="十、-作用域、作用链？"><a href="#十、-作用域、作用链？" class="headerlink" title="十、 作用域、作用链？"></a><a name='10'>十、 作用域、作用链？</a></h2><h4 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h4><pre><code class="js">就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域1、全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的；2、局部作用域： 局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以 在函数的外面无法访问函数内的变量3、块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域(let或者const )</code></pre><h4 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h4><pre><code class="js">作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。作用域链的创建过程跟执行上下文的建立有关....//回答：作用域链本质是一个指向变量的指针列表，通过作用域链，我可以访问到外层环境的函数和变量，也就是说，当我们访问一个变量时，回现在当前作用域中寻找，找不到就会依次向上级作用域中去寻找，直到全局作用域，作用域表示的是变量的可访问范围，有全局作用域，局部作用域，块级作用域...（加上作用域的知识）连环问（了解）：如何延长作用域链？作用域链是可以延长的延长作用域链：执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除具体来说就是执行这两个语句时，作用域链都会得到加强1、try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声明2、with 语句。with 语句会将指定的对象添加到作用域链中</code></pre><h2 id="十一、-什么是闭包呀？它有什么作用？会造成什么问题？在哪些实际场景上有应用呢？"><a href="#十一、-什么是闭包呀？它有什么作用？会造成什么问题？在哪些实际场景上有应用呢？" class="headerlink" title="十一、 什么是闭包呀？它有什么作用？会造成什么问题？在哪些实际场景上有应用呢？"></a><a name='11'>十一、 什么是闭包呀？它有什么作用？会造成什么问题？在哪些实际场景上有应用呢？</a></h2><h4 id="1、闭包"><a href="#1、闭包" class="headerlink" title="1、闭包"></a>1、闭包</h4><pre><code class="js">MDN: 闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。我理解的闭包是内层函数引用外层函数变量的集合，也就是闭包是等于内层函数加上外层函数变量，注意内层函数对外层函数的引用(也就是地址)，而不是直接取值。外层变量会存在堆里面的闭包对象上，闭包对象在作用域对象里面，这就是闭包会泄漏的原因：当外层函数执行完成之后，我们仍能访问到外层的变量，是因为外层变量被存到了闭包对象里面。</code></pre><h4 id="2、闭包的作用"><a href="#2、闭包的作用" class="headerlink" title="2、闭包的作用"></a>2、闭包的作用</h4><pre><code class="js">1.外部函数可以访问内部函数的变量，但是不能修改，通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，2.可以使用以上这种方法来创建私有变量。</code></pre><h4 id="3、问题"><a href="#3、问题" class="headerlink" title="3、问题"></a>3、问题</h4><pre><code class="js">因为闭包函数会保留对这个变量的引用，所以这个变量不会被回收，所以可能会造成内存泄漏</code></pre><h4 id="4、实际应用"><a href="#4、实际应用" class="headerlink" title="4、实际应用"></a>4、实际应用</h4><pre><code class="js">做一些性能优化，如：防抖、节流柯里化</code></pre><h2 id="十二、垃圾回收机制、内存泄漏？"><a href="#十二、垃圾回收机制、内存泄漏？" class="headerlink" title="十二、垃圾回收机制、内存泄漏？"></a><a name='12'>十二、垃圾回收机制、内存泄漏？</a></h2><h4 id="1、垃圾回收机制"><a href="#1、垃圾回收机制" class="headerlink" title="1、垃圾回收机制"></a>1、垃圾回收机制</h4><p>内存不在使用时，就会被垃圾回收机制自动回收（js分配资源和回收垃圾都是内部自动完成的）</p><pre><code class="js">垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。这个时候，不仅自己的程序无法正常运行，连其他程序也会受到影响。好比生物只有出生没有死亡，地球总有被撑爆的一天。所以，在计算机中，我们需要垃圾回收。需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，JavaScript 中依旧会出现内存溢出的情况。</code></pre><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/23992332">https://zhuanlan.zhihu.com/p/23992332</a></p></blockquote><h4 id="2、垃圾回收的方法"><a href="#2、垃圾回收的方法" class="headerlink" title="2、垃圾回收的方法"></a>2、垃圾回收的方法</h4><ul><li><p><strong>引用计数法(淘汰)</strong></p><ul><li><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加一；当引用失效时，计数器的值就减一。当某一时刻计数器的值为零时，这个对象就不再被使用。就会垃圾回收</p></li><li><p>引用计数法的优势是简单、效率高。缺点也很明显单纯的引用计数很难解决对象之间的循环引用问题(对象互相引用)</p></li></ul></li></ul><pre><code class="bash">function func() &#123;    let obj1 = &#123;&#125;;    let obj2 = &#123;&#125;;    obj1.a = obj2; // obj1 引用 obj2    obj2.a = obj1; // obj2 引用 obj1&#125;当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</code></pre><ul><li><p><strong>标记-清除法（mark and sweep）</strong></p><ul><li><p>垃圾回收期将从window这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象，对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象,也可以反过来，标记需要清除的对象，然后清除这些标记了的对象</p></li><li><p>简单来说：从全局作用域找，不能被访问到就清除</p></li></ul></li></ul><h4 id="3、内存泄漏情况"><a href="#3、内存泄漏情况" class="headerlink" title="3、内存泄漏情况"></a>3、内存泄漏情况</h4><p>内存泄漏指的是不再用到的内存没有被及时被释放，从而内存泄漏</p><ul><li>意外的全局变量：我们使用了一个没有声明的变量，就有可能创建了一个全局变量，而使这个变量一直留在内存中无法被回收</li></ul><pre><code class="javascript">function foo(arg) &#123;    const bar = &quot;&quot;;&#125;foo();当 foo 函数执行后，变量 bar 就会被标记为可回收。因为当函数执行时，函数创造了一个作用域来让函数里的变量在里面声明。进入这个作用域后，浏览器就会为变量 bar 创建一个内存空间。当这个函数结束后，其所创建的作用域里的变量也会被标记为垃圾，在下一个垃圾回收周期到来时，这些变量将会被回收。</code></pre><ul><li>回调函数或者计时器被遗忘：我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>脱离 DOM 的引用：我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li><li>闭包</li></ul><h2 id="十三、new-操作符具体干了什么呢？如何实现？"><a href="#十三、new-操作符具体干了什么呢？如何实现？" class="headerlink" title="十三、new 操作符具体干了什么呢？如何实现？"></a><a name='13'>十三、new 操作符具体干了什么呢？如何实现？</a></h2><pre><code class="js">1.创建一个空对象2.让this指向这个对象3.函数体执行，给this添加属性和方法4.返回thisnew共经历了四个过程。var fn = function () &#123; &#125;;var fnObj = new fn();1、创建了一个空对象var obj = new object();2、设置原型链obj._proto_ = fn.prototype;3、让fn的this指向obj，并执行fn的函数体var result = fn.call(obj)4、判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。if (typeof(result) == &quot;object&quot;)&#123;      fnObj = result;  &#125; else &#123;      fnObj = obj;&#125;  </code></pre><p><strong>手写实现</strong>：</p><pre><code class="js">//简单版：   function myNew(fn, ...args) &#123;        let obj = new Object()        obj.__proto__ = fn.prototype        let res = fn.call(obj, ...args)        if (res &amp;&amp; (typeof res === &#39;object&#39; || typeof res === &#39;function&#39;)) return res        else return obj    &#125;//完整版：function objectFactory() &#123;  let newObject = null,    constructor = Array.prototype.shift.call(arguments),    result = null;  // 参数判断  if (typeof constructor !== &quot;function&quot;) &#123;    console.error(&quot;type error&quot;);    return;  &#125;  // 新建一个空对象，对象的原型为构造函数的 prototype 对象  newObject = Object.create(constructor.prototype);  // 将 this 指向新建对象，并执行函数  result = constructor.apply(newObject, arguments);  // 判断返回对象  let flag =    result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);  // 判断返回结果  return flag ? result : newObject;&#125;// 使用方法// objectFactory(构造函数, 初始化参数);</code></pre><h2 id="十四、script标签的defer和aync-属性"><a href="#十四、script标签的defer和aync-属性" class="headerlink" title="十四、script标签的defer和aync 属性"></a><a name='14'>十四、script标签的defer和aync 属性</a></h2><pre><code class="js">1、js脚本会阻塞DOM解析；2、defer和async 属性都会异步加载js 脚本，3、defer会在DOMContentLoaded事件触发之前执行脚本，也就是DOM树构建完成之前触发（所有这里做DOM操作时不会引起回流和重绘），4、async则是下载完js脚本就直接执行，不管是在哪个时间点，所以不适合做DOM操作，可能会引起回流重绘</code></pre><h2 id="十五、-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#十五、-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="十五、 Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a><a name='15'>十五、 Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></h2><pre><code>hasOwnProperty所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</code></pre><h2 id="十六、谈谈对this的理解"><a href="#十六、谈谈对this的理解" class="headerlink" title="十六、谈谈对this的理解"></a><a name='16'>十六、谈谈对this的理解</a></h2><blockquote><p>this是执行上下文中的一个属性，它指向最后一次调用这个方法的对象</p></blockquote><ul><li>在全局环境中，this指向window</li><li>构造函数的this指向实例对象</li><li>函数内部，this指向取决于这个函数被调用的方式、<ul><li>普通函数直接调用，this指向window</li><li>函数作为对象的方法调用，this指向这个对象</li><li>在绑定DOM元素给其注册事件时，this指向这个DOM元素</li></ul></li><li>call 、apply 、bind 绑定this，this指向绑定的对象</li><li>箭头函数本身没有this，它的this在创建的时候就确定了，指向外层的作用域，而其他函数的this指向是调用的时候才确定</li></ul><p><strong>this的优先级</strong></p><ul><li>new（构造函数）&gt; bind &gt; call &#x3D; apply &gt; 隐式绑定 &gt; 普通函数的调用</li></ul><h2 id="十七、call、apply、bind？"><a href="#十七、call、apply、bind？" class="headerlink" title="十七、call、apply、bind？"></a><a name='17'>十七、call、apply、bind？</a></h2><p>- </p><h2 id="十八、Array-from"><a href="#十八、Array-from" class="headerlink" title="十八、Array.from"></a><a name='18'>十八、Array.from</a></h2><ul><li>Array.from 可以将一个伪数组转化为真数组</li><li>Array.from对数组进行浅拷贝</li><li>使用值填充数组</li></ul><pre><code class="javascript">const length = 3;const init   = 0;const result = Array.from(&#123; length &#125;, () =&gt; init);console.log(result)//[0,0,0]result 是一个新的数组，它的长度为3，数组的每一项都是0。调用 Array.from() 方法，传入一个类数组对象 &#123; length &#125; 和 返回初始化值的 mapFunction 函数。当初始化数组的每个项都应该是一个新对象时Array.from() 是一个更好的解决方案:const length = 3;const resultA = Array.from(&#123; length &#125;, () =&gt; (&#123;&#125;));const resultB = Array(length).fill(&#123;&#125;);resultA; // =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]resultB; // =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]</code></pre><ul><li><code>Array.from()</code> 生成值范围</li></ul><pre><code class="javascript">function range(end) &#123;    return Array.from(&#123; length: end &#125;, (_, index) =&gt; index);&#125;range(4); // =&gt; [0, 1, 2, 3]在 range() 函数中，Array.from() 提供了类似数组的 &#123;length：end&#125; ，以及一个简单地返回当前索引的 map 函数 。这样你就可以生成值范围。</code></pre><h2 id="十九、new-Array和Array-of"><a href="#十九、new-Array和Array-of" class="headerlink" title="十九、new Array和Array of"></a><a name='19'>十九、new Array和Array of</a></h2><pre><code class="js">let arr = Array(1, 2, 3, 4)console.log(arr) // 1, 2, 3, 4console.log(arr.length) // 4let arr = new Array(4) //这种方式不可迭代，可以用Array.from转化为可迭代的数组 用Array.from(&#123;length:10&#125;)生成的空数组 可以迭代console.log(arr) // [empty × 4]console.log(arr.length) // 4let arr = Array.of(1, 2, 3, 4)console.log(arr) // [1, 2, 3, 4]console.log(arr.length) // 4let arr = Array.of(4)console.log(arr) // [4]console.log(arr.length) // 1</code></pre><h2 id="二十、可选链"><a href="#二十、可选链" class="headerlink" title="二十、可选链 ?."></a><a name='20'>二十、可选链 <code>?.</code></a></h2><p>​可选链 <code>?.</code> 语法有三种形式：</p><ol><li><p><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。</p></li><li><p><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj[prop]</code>，否则返回 <code>undefined</code>。</p></li><li><p><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code></p><p><code>?.</code> 链使我们能够安全地访问嵌套属性</p><p>但是，我们应该谨慎地使用 <code>?.</code></p><p>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p><pre><code class="js">let user = &#123;&#125;; // user 没有 address 属性alert( user?.address?.street ); // undefined（不报错）</code></pre></li></ol><h2 id="二十一、promise-allsettled"><a href="#二十一、promise-allsettled" class="headerlink" title="二十一、promise.allsettled "></a><a name='21'>二十一、promise.allsettled </a></h2><pre><code class="js">  Promise.allSettled跟Promise.all类似, 其参数接受一个Promise的数组, 返回一个新的Promise, 唯一的不同在于, 其不会进行短路, 也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态, 而不管其是否处理成功.它返回一个Array的Promise</code></pre><h2 id="二十二、array-x3D-vs-array-length-x3D-0"><a href="#二十二、array-x3D-vs-array-length-x3D-0" class="headerlink" title="二十二、array &#x3D; [] vs array.length &#x3D; 0 "></a><a name='22'>二十二、array &#x3D; [] vs array.length &#x3D; 0 </a></h2><pre><code class="js">//array = []let foo = [&#39;hello&#39;, &#39;world&#39;];// Add a referencelet bar = foo;foo = [];// `bar` isn&#39;t affectedconsole.log(bar); // [&#39;hello&#39;, &#39;world&#39;]//array.length = 0let foo = [&#39;hello&#39;, &#39;world&#39;];let bar = foo;foo.length = 0;// `bar` is affectedconsole.log(bar); // []</code></pre><h2 id="二十三、-和-amp-amp-操作符的返回值？"><a href="#二十三、-和-amp-amp-操作符的返回值？" class="headerlink" title="二十三、|| 和 &amp;&amp; 操作符的返回值？ "></a><a name='23'>二十三、|| 和 &amp;&amp; 操作符的返回值？ </a></h2><pre><code class="js">|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</code></pre><h2 id="二十四、为什么需要微任务、宏任务？"><a href="#二十四、为什么需要微任务、宏任务？" class="headerlink" title="二十四、为什么需要微任务、宏任务？ "></a><a name='24'>二十四、为什么需要微任务、宏任务？ </a></h2><ul><li>单线程语言，阻塞执行</li><li>JS做的任务分为同步和异步两种，所谓 “异步”，简单说就是一个任务不是连续完成的，先执行第一段，等做好了准备，再回过头执行第二段，第二段也被叫做回调；同步则是连贯完成的。</li><li>常见的宏任务有：script（整体代码）&#x2F;setTimout&#x2F;setInterval&#x2F;setImmediate(node 独有)&#x2F;requestAnimationFrame(浏览器独有)&#x2F;IO&#x2F;UI render（浏览器独有）</li></ul><h2 id="二十五、Promise并发控制"><a href="#二十五、Promise并发控制" class="headerlink" title="二十五、Promise并发控制 "></a><a name='25'>二十五、Promise并发控制 </a></h2><p>利用Promise模拟并发下载:一共有 12个图片，同一时间的并发数不超过4个</p><ul><li><p>slice()</p></li><li><p>promise.race()</p></li></ul><h2 id="二十六、构造一个全为0的数组（两种方法）"><a href="#二十六、构造一个全为0的数组（两种方法）" class="headerlink" title="二十六、构造一个全为0的数组（两种方法） "></a><a name='26'>二十六、构造一个全为0的数组（两种方法） </a></h2><p>array.from 和 fill()</p><h2 id="二十七、数组的扁平化以及扁平化数组转化为树状结构数组"><a href="#二十七、数组的扁平化以及扁平化数组转化为树状结构数组" class="headerlink" title="二十七、数组的扁平化以及扁平化数组转化为树状结构数组 "></a><a name='27'>二十七、数组的扁平化以及扁平化数组转化为树状结构数组 </a></h2><h4 id="1、扁平数组转化为树状结构数组"><a href="#1、扁平数组转化为树状结构数组" class="headerlink" title="1、扁平数组转化为树状结构数组:"></a>1、扁平数组转化为树状结构数组:</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;  let depts = [    &#123; id: 1, name: &#39;节点1&#39;, pid: &#39;&#39; &#125;,    &#123; id: 11, name: &#39;节点1-1&#39;, pid: 1 &#125;,    &#123; id: 111, name: &#39;节点1-1-1&#39;, pid: 11 &#125;,    &#123; id: 12, name: &#39;节点1-2&#39;, pid: 1 &#125;,    &#123; id: 2, name: &#39;节点2&#39;, pid: &#39;&#39; &#125;,    &#123; id: 21, name: &#39;节点2-1&#39;, pid: 2 &#125;,  ]  //扁平数组转换为树状结构数组  // 1.循环  // depts.forEach(item =&gt; &#123;  //   const children = depts.filter(el =&gt; el.pid === item.id)  //   if (children.length &gt; 0) &#123;  //     item.children = children  //   &#125;  // &#125;)  // console.log(depts)  // const list = depts.filter(item =&gt;item.pid === &#39;&#39; )  // console.log(list)  // 2.递归  function tanslateArray (flatArr,pid) &#123;    let newArr = flatArr.filter(m =&gt; m.pid === pid)    depts.forEach(item =&gt; &#123;      if (item.pid === pid) &#123;        let children = tanslateArray(flatArr,item.id)        if (children.length &gt; 0) &#123;          item.children = children        &#125;      &#125;    &#125;)    return newArr  &#125;  let list = tanslateArray(depts,&#39;&#39;)  console.log(list)&lt;/script&gt;&lt;/html&gt;</code></pre><h4 id="2、扁平化数组"><a href="#2、扁平化数组" class="headerlink" title="2、扁平化数组:"></a>2、扁平化数组:</h4><pre><code class="js">需求:多维数组=&gt;一维数组let ary = [1, [2, [3, [4, 5]]], 6];let str = JSON.stringify(ary);第0种处理:直接的调用arr_flat = arr.flat(Infinity);第一种处理ary = str.replace(/(\[\]))/g, &#39;&#39;).split(&#39;,&#39;);第二种处理str = str.replace(/(\[\]))/g, &#39;&#39;);str = &#39;[&#39; + str + &#39;]&#39;;ary = JSON.parse(str);第三种处理：递归处理let result = [];        let fn = function (ary) &#123;            for (let i = 0; i &lt; ary.length; i++) &#123;                let item = ary[i];                if (Array.isArray(ary[i])) &#123;                    fn(item);                &#125; else &#123;                    result.push(item);                &#125;            &#125;            return result        &#125;        console.log(fn([1,2,[3,4,[5,6]]]))第四种处理：用 reduce 实现数组的 flat 方法function flatten(ary) &#123;            return ary.reduce((pre, cur) =&gt; &#123;                return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)            &#125;,[])//[]表示初始值        &#125;        let ary = [1, 2, [3, 4], [5, [6, 7]]]       console.log( flatten(ary))第五种处理：扩展运算符while (ary.some(Array.isArray)) &#123;ary = [].concat(...ary);&#125;</code></pre><h2 id="二十八、Blob、ArrayBuffer"><a href="#二十八、Blob、ArrayBuffer" class="headerlink" title="二十八、Blob、ArrayBuffer "></a><a name='28'>二十八、Blob、ArrayBuffer </a></h2><h4 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h4><p><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 来用于数据操作</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size"><code>Blob.prototype.size</code></a> 只读</p><ul><li><code>Blob</code> 对象中所包含数据的大小（字节）。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type"><code>Blob.prototype.type</code></a> 只读</p><ul><li>一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</li></ul><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><blockquote><p>参考：<a href="https://es6.ruanyifeng.com/#docs/arraybuffer">https://es6.ruanyifeng.com/#docs/arraybuffer</a></p></blockquote><h2 id="二十九、合并两个数组对象"><a href="#二十九、合并两个数组对象" class="headerlink" title="二十九、合并两个数组对象 "></a><a name='29'>二十九、合并两个数组对象 </a></h2><pre><code class="bash">//实现一个函数，将两个对象数组合并到uuid 上，但首先有uuid 和 // name，second 有 uuid 和 role。对于不存在的属性，填充为空。种类合并后根据uuid。 //根据id合并两个数组对象        let arr = [            &#123; uuid: 2, name: &quot;test&quot; &#125;,             &#123; uuid: 5, name: &quot;test5&quot; &#125;,            &#123; uuid: 3, name: &quot;test3&quot; &#125;        ]        let arr1 = [            &#123; uuid: 6, role: &quot;pm&quot; &#125;,            &#123; uuid: 4, role: &quot;engineer&quot; &#125;,            &#123; uuid: 1, role: &quot;manager&quot; &#125;,            &#123; uuid: 2, role: &quot;associate&quot; &#125;]        // const newArr = []        // arr.forEach((item, index) =&gt; &#123;        //     let target = arr1.find(ee =&gt; ee.uuid == item.uuid)        //     console.log(target)        //     if (target) &#123;        //         const temp = Object.assign(item, target)        //         newArr.push(temp)        //         arr1.splice(arr1.indexOf(target), 1)        //     &#125; else &#123;        //         newArr.push(item)        //     &#125;        // &#125;)        // console.log(...arr1, ...newArr)        // function Fn (arr, arr1) &#123;        //     const newArr = []        //     arr.forEach((item, index) =&gt; &#123;        //         let target = arr1.find(ee =&gt; ee.uuid == item.uuid)        //         console.log(target)        //         if (target) &#123;        //             const temp = Object.assign(item, target)        //             newArr.push(temp)        //             arr1.splice(arr1.indexOf(target), 1)        //         &#125; else &#123;        //             newArr.push(item)        //         &#125;        //     &#125;)        //     return [...arr1, ...newArr]        // &#125;        // console.log(Fn(arr, arr1))</code></pre><h2 id="三十、数组随机排序"><a href="#三十、数组随机排序" class="headerlink" title="三十、数组随机排序 "></a><a name='30'>三十、数组随机排序 </a></h2><pre><code class="js">//1、随机从原数组中抽取一个元素加入到新数组        const arr1 = [1,2,6,4,5,4,0]        const newarr = []        while(arr1.length &gt; 0)&#123;            const num = Math.floor(Math.random()*arr1.length)            newarr.push(arr1[num])            arr1.splice(num,1)        &#125;        console.log(newarr)//2.ES6交换两个元素function randomSort(array) &#123;          let length = array.length;                  if (!Array.isArray(array) || length &lt;= 1) return;                  for (let index = 0; index &lt; length - 1; index++) &#123;            let randomIndex = Math.floor(Math.random() * (length - index)) + index;                    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];          &#125;                  return array;        &#125;        console.log(randomSort([1,2,6,8,4,5]))</code></pre><h2 id="三十一、如何终止一个forEach"><a href="#三十一、如何终止一个forEach" class="headerlink" title="三十一、如何终止一个forEach "></a><a name='31'>三十一、如何终止一个forEach </a></h2><p>用 break continue 和return都是不能打断一个forEach</p><p>解决方法：</p><ul><li>用try–catch 结合throw 一个错误</li><li>用其他方法 如some 和every</li></ul><h2 id="三十二、JavaScript传参的方式"><a href="#三十二、JavaScript传参的方式" class="headerlink" title="三十二、JavaScript传参的方式 "></a><a name='32'>三十二、JavaScript传参的方式 </a></h2><ul><li><p><strong>cookie传参</strong></p><ul><li>可以<code>doucment.cookie</code>来进行cookie的读取或者设置、删除等操作</li></ul></li></ul><pre><code class="js">//创建cookie document.cookie=&quot;username=szgy&quot;;//读取cookievar x = document.cookie;</code></pre><ul><li><p><strong>URL传参</strong></p><ul><li>可以在URL后面拼接参数进行传参，例如:<code>http://xxx.com?username=szgy&amp;password=123456</code></li><li>这种方式的优点是可以跨域</li></ul></li><li><p><strong>localstorage或者sessionstorage传参</strong></p></li></ul><h2 id="三十三、0-1-0-2-x3D-x3D-x3D-0-3-嘛？为什么？"><a href="#三十三、0-1-0-2-x3D-x3D-x3D-0-3-嘛？为什么？" class="headerlink" title="三十三、0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 嘛？为什么？"></a><a name='33'>三十三、0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 嘛？为什么？</a></h2><pre><code class="js">在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行对阶运算，JS 引擎对二进制进行截断所以造成精度丢失</code></pre><h2 id="三十四、javascript-创建对象的几种方式？"><a href="#三十四、javascript-创建对象的几种方式？" class="headerlink" title=" 三十四、javascript 创建对象的几种方式？"></a><a name='35'> 三十四、javascript 创建对象的几种方式？</a></h2>]]></content>
    
    
    <summary type="html">采用简约大方的扁平化Hexo-Quiet主题</summary>
    
    
    
    <category term="前端学习" scheme="https://szgyfe.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端面试" scheme="https://szgyfe.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端学习" scheme="https://szgyfe.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="前端笔记" scheme="https://szgyfe.github.io/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript" scheme="https://szgyfe.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
